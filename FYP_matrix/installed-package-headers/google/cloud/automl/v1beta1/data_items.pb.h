// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/automl/v1beta1/data_items.proto

#ifndef PROTOBUF_INCLUDED_google_2fcloud_2fautoml_2fv1beta1_2fdata_5fitems_2eproto
#define PROTOBUF_INCLUDED_google_2fcloud_2fautoml_2fv1beta1_2fdata_5fitems_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/cloud/automl/v1beta1/io.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_google_2fcloud_2fautoml_2fv1beta1_2fdata_5fitems_2eproto 

namespace protobuf_google_2fcloud_2fautoml_2fv1beta1_2fdata_5fitems_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_google_2fcloud_2fautoml_2fv1beta1_2fdata_5fitems_2eproto
namespace google {
namespace cloud {
namespace automl {
namespace v1beta1 {
class ExamplePayload;
class ExamplePayloadDefaultTypeInternal;
extern ExamplePayloadDefaultTypeInternal _ExamplePayload_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class TextSnippet;
class TextSnippetDefaultTypeInternal;
extern TextSnippetDefaultTypeInternal _TextSnippet_default_instance_;
}  // namespace v1beta1
}  // namespace automl
}  // namespace cloud
}  // namespace google
namespace google {
namespace protobuf {
template<> ::google::cloud::automl::v1beta1::ExamplePayload* Arena::CreateMaybeMessage<::google::cloud::automl::v1beta1::ExamplePayload>(Arena*);
template<> ::google::cloud::automl::v1beta1::Image* Arena::CreateMaybeMessage<::google::cloud::automl::v1beta1::Image>(Arena*);
template<> ::google::cloud::automl::v1beta1::TextSnippet* Arena::CreateMaybeMessage<::google::cloud::automl::v1beta1::TextSnippet>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace google {
namespace cloud {
namespace automl {
namespace v1beta1 {

// ===================================================================

class Image : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.automl.v1beta1.Image) */ {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(Image&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  enum DataCase {
    kImageBytes = 1,
    kInputConfig = 6,
    DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Image* other);
  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const final {
    return CreateMaybeMessage<Image>(NULL);
  }

  Image* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string thumbnail_uri = 4;
  void clear_thumbnail_uri();
  static const int kThumbnailUriFieldNumber = 4;
  const ::std::string& thumbnail_uri() const;
  void set_thumbnail_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_thumbnail_uri(::std::string&& value);
  #endif
  void set_thumbnail_uri(const char* value);
  void set_thumbnail_uri(const char* value, size_t size);
  ::std::string* mutable_thumbnail_uri();
  ::std::string* release_thumbnail_uri();
  void set_allocated_thumbnail_uri(::std::string* thumbnail_uri);

  // bytes image_bytes = 1;
  private:
  bool has_image_bytes() const;
  public:
  void clear_image_bytes();
  static const int kImageBytesFieldNumber = 1;
  const ::std::string& image_bytes() const;
  void set_image_bytes(const ::std::string& value);
  #if LANG_CXX11
  void set_image_bytes(::std::string&& value);
  #endif
  void set_image_bytes(const char* value);
  void set_image_bytes(const void* value, size_t size);
  ::std::string* mutable_image_bytes();
  ::std::string* release_image_bytes();
  void set_allocated_image_bytes(::std::string* image_bytes);

  // .google.cloud.automl.v1beta1.InputConfig input_config = 6;
  bool has_input_config() const;
  void clear_input_config();
  static const int kInputConfigFieldNumber = 6;
  private:
  const ::google::cloud::automl::v1beta1::InputConfig& _internal_input_config() const;
  public:
  const ::google::cloud::automl::v1beta1::InputConfig& input_config() const;
  ::google::cloud::automl::v1beta1::InputConfig* release_input_config();
  ::google::cloud::automl::v1beta1::InputConfig* mutable_input_config();
  void set_allocated_input_config(::google::cloud::automl::v1beta1::InputConfig* input_config);

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.Image)
 private:
  void set_has_image_bytes();
  void set_has_input_config();

  inline bool has_data() const;
  inline void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr thumbnail_uri_;
  union DataUnion {
    DataUnion() {}
    ::google::protobuf::internal::ArenaStringPtr image_bytes_;
    ::google::cloud::automl::v1beta1::InputConfig* input_config_;
  } data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_google_2fcloud_2fautoml_2fv1beta1_2fdata_5fitems_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TextSnippet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.automl.v1beta1.TextSnippet) */ {
 public:
  TextSnippet();
  virtual ~TextSnippet();

  TextSnippet(const TextSnippet& from);

  inline TextSnippet& operator=(const TextSnippet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TextSnippet(TextSnippet&& from) noexcept
    : TextSnippet() {
    *this = ::std::move(from);
  }

  inline TextSnippet& operator=(TextSnippet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TextSnippet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextSnippet* internal_default_instance() {
    return reinterpret_cast<const TextSnippet*>(
               &_TextSnippet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TextSnippet* other);
  friend void swap(TextSnippet& a, TextSnippet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TextSnippet* New() const final {
    return CreateMaybeMessage<TextSnippet>(NULL);
  }

  TextSnippet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TextSnippet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TextSnippet& from);
  void MergeFrom(const TextSnippet& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextSnippet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string content = 1;
  void clear_content();
  static const int kContentFieldNumber = 1;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // string mime_type = 2;
  void clear_mime_type();
  static const int kMimeTypeFieldNumber = 2;
  const ::std::string& mime_type() const;
  void set_mime_type(const ::std::string& value);
  #if LANG_CXX11
  void set_mime_type(::std::string&& value);
  #endif
  void set_mime_type(const char* value);
  void set_mime_type(const char* value, size_t size);
  ::std::string* mutable_mime_type();
  ::std::string* release_mime_type();
  void set_allocated_mime_type(::std::string* mime_type);

  // string content_uri = 4;
  void clear_content_uri();
  static const int kContentUriFieldNumber = 4;
  const ::std::string& content_uri() const;
  void set_content_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_content_uri(::std::string&& value);
  #endif
  void set_content_uri(const char* value);
  void set_content_uri(const char* value, size_t size);
  ::std::string* mutable_content_uri();
  ::std::string* release_content_uri();
  void set_allocated_content_uri(::std::string* content_uri);

  // @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.TextSnippet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::internal::ArenaStringPtr mime_type_;
  ::google::protobuf::internal::ArenaStringPtr content_uri_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fcloud_2fautoml_2fv1beta1_2fdata_5fitems_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExamplePayload : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.automl.v1beta1.ExamplePayload) */ {
 public:
  ExamplePayload();
  virtual ~ExamplePayload();

  ExamplePayload(const ExamplePayload& from);

  inline ExamplePayload& operator=(const ExamplePayload& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExamplePayload(ExamplePayload&& from) noexcept
    : ExamplePayload() {
    *this = ::std::move(from);
  }

  inline ExamplePayload& operator=(ExamplePayload&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExamplePayload& default_instance();

  enum PayloadCase {
    kImage = 1,
    kTextSnippet = 2,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExamplePayload* internal_default_instance() {
    return reinterpret_cast<const ExamplePayload*>(
               &_ExamplePayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ExamplePayload* other);
  friend void swap(ExamplePayload& a, ExamplePayload& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExamplePayload* New() const final {
    return CreateMaybeMessage<ExamplePayload>(NULL);
  }

  ExamplePayload* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExamplePayload>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExamplePayload& from);
  void MergeFrom(const ExamplePayload& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExamplePayload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.cloud.automl.v1beta1.Image image = 1;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 1;
  private:
  const ::google::cloud::automl::v1beta1::Image& _internal_image() const;
  public:
  const ::google::cloud::automl::v1beta1::Image& image() const;
  ::google::cloud::automl::v1beta1::Image* release_image();
  ::google::cloud::automl::v1beta1::Image* mutable_image();
  void set_allocated_image(::google::cloud::automl::v1beta1::Image* image);

  // .google.cloud.automl.v1beta1.TextSnippet text_snippet = 2;
  bool has_text_snippet() const;
  void clear_text_snippet();
  static const int kTextSnippetFieldNumber = 2;
  private:
  const ::google::cloud::automl::v1beta1::TextSnippet& _internal_text_snippet() const;
  public:
  const ::google::cloud::automl::v1beta1::TextSnippet& text_snippet() const;
  ::google::cloud::automl::v1beta1::TextSnippet* release_text_snippet();
  ::google::cloud::automl::v1beta1::TextSnippet* mutable_text_snippet();
  void set_allocated_text_snippet(::google::cloud::automl::v1beta1::TextSnippet* text_snippet);

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.ExamplePayload)
 private:
  void set_has_image();
  void set_has_text_snippet();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PayloadUnion {
    PayloadUnion() {}
    ::google::cloud::automl::v1beta1::Image* image_;
    ::google::cloud::automl::v1beta1::TextSnippet* text_snippet_;
  } payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_google_2fcloud_2fautoml_2fv1beta1_2fdata_5fitems_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Image

// bytes image_bytes = 1;
inline bool Image::has_image_bytes() const {
  return data_case() == kImageBytes;
}
inline void Image::set_has_image_bytes() {
  _oneof_case_[0] = kImageBytes;
}
inline void Image::clear_image_bytes() {
  if (has_image_bytes()) {
    data_.image_bytes_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_data();
  }
}
inline const ::std::string& Image::image_bytes() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.Image.image_bytes)
  if (has_image_bytes()) {
    return data_.image_bytes_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Image::set_image_bytes(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.Image.image_bytes)
  if (!has_image_bytes()) {
    clear_data();
    set_has_image_bytes();
    data_.image_bytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  data_.image_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.Image.image_bytes)
}
#if LANG_CXX11
inline void Image::set_image_bytes(::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.Image.image_bytes)
  if (!has_image_bytes()) {
    clear_data();
    set_has_image_bytes();
    data_.image_bytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  data_.image_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.automl.v1beta1.Image.image_bytes)
}
#endif
inline void Image::set_image_bytes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_image_bytes()) {
    clear_data();
    set_has_image_bytes();
    data_.image_bytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  data_.image_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.automl.v1beta1.Image.image_bytes)
}
inline void Image::set_image_bytes(const void* value, size_t size) {
  if (!has_image_bytes()) {
    clear_data();
    set_has_image_bytes();
    data_.image_bytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  data_.image_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.automl.v1beta1.Image.image_bytes)
}
inline ::std::string* Image::mutable_image_bytes() {
  if (!has_image_bytes()) {
    clear_data();
    set_has_image_bytes();
    data_.image_bytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.automl.v1beta1.Image.image_bytes)
  return data_.image_bytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Image::release_image_bytes() {
  // @@protoc_insertion_point(field_release:google.cloud.automl.v1beta1.Image.image_bytes)
  if (has_image_bytes()) {
    clear_has_data();
    return data_.image_bytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Image::set_allocated_image_bytes(::std::string* image_bytes) {
  if (!has_image_bytes()) {
    data_.image_bytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_data();
  if (image_bytes != NULL) {
    set_has_image_bytes();
    data_.image_bytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image_bytes);
  }
  // @@protoc_insertion_point(field_set_allocated:google.cloud.automl.v1beta1.Image.image_bytes)
}

// .google.cloud.automl.v1beta1.InputConfig input_config = 6;
inline bool Image::has_input_config() const {
  return data_case() == kInputConfig;
}
inline void Image::set_has_input_config() {
  _oneof_case_[0] = kInputConfig;
}
inline const ::google::cloud::automl::v1beta1::InputConfig& Image::_internal_input_config() const {
  return *data_.input_config_;
}
inline ::google::cloud::automl::v1beta1::InputConfig* Image::release_input_config() {
  // @@protoc_insertion_point(field_release:google.cloud.automl.v1beta1.Image.input_config)
  if (has_input_config()) {
    clear_has_data();
      ::google::cloud::automl::v1beta1::InputConfig* temp = data_.input_config_;
    data_.input_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::google::cloud::automl::v1beta1::InputConfig& Image::input_config() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.Image.input_config)
  return has_input_config()
      ? *data_.input_config_
      : *reinterpret_cast< ::google::cloud::automl::v1beta1::InputConfig*>(&::google::cloud::automl::v1beta1::_InputConfig_default_instance_);
}
inline ::google::cloud::automl::v1beta1::InputConfig* Image::mutable_input_config() {
  if (!has_input_config()) {
    clear_data();
    set_has_input_config();
    data_.input_config_ = CreateMaybeMessage< ::google::cloud::automl::v1beta1::InputConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.automl.v1beta1.Image.input_config)
  return data_.input_config_;
}

// string thumbnail_uri = 4;
inline void Image::clear_thumbnail_uri() {
  thumbnail_uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Image::thumbnail_uri() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.Image.thumbnail_uri)
  return thumbnail_uri_.GetNoArena();
}
inline void Image::set_thumbnail_uri(const ::std::string& value) {
  
  thumbnail_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.Image.thumbnail_uri)
}
#if LANG_CXX11
inline void Image::set_thumbnail_uri(::std::string&& value) {
  
  thumbnail_uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.automl.v1beta1.Image.thumbnail_uri)
}
#endif
inline void Image::set_thumbnail_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  thumbnail_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.automl.v1beta1.Image.thumbnail_uri)
}
inline void Image::set_thumbnail_uri(const char* value, size_t size) {
  
  thumbnail_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.automl.v1beta1.Image.thumbnail_uri)
}
inline ::std::string* Image::mutable_thumbnail_uri() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.automl.v1beta1.Image.thumbnail_uri)
  return thumbnail_uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Image::release_thumbnail_uri() {
  // @@protoc_insertion_point(field_release:google.cloud.automl.v1beta1.Image.thumbnail_uri)
  
  return thumbnail_uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_thumbnail_uri(::std::string* thumbnail_uri) {
  if (thumbnail_uri != NULL) {
    
  } else {
    
  }
  thumbnail_uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), thumbnail_uri);
  // @@protoc_insertion_point(field_set_allocated:google.cloud.automl.v1beta1.Image.thumbnail_uri)
}

inline bool Image::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void Image::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline Image::DataCase Image::data_case() const {
  return Image::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TextSnippet

// string content = 1;
inline void TextSnippet::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TextSnippet::content() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.TextSnippet.content)
  return content_.GetNoArena();
}
inline void TextSnippet::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.TextSnippet.content)
}
#if LANG_CXX11
inline void TextSnippet::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.automl.v1beta1.TextSnippet.content)
}
#endif
inline void TextSnippet::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.automl.v1beta1.TextSnippet.content)
}
inline void TextSnippet::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.automl.v1beta1.TextSnippet.content)
}
inline ::std::string* TextSnippet::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.automl.v1beta1.TextSnippet.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextSnippet::release_content() {
  // @@protoc_insertion_point(field_release:google.cloud.automl.v1beta1.TextSnippet.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextSnippet::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:google.cloud.automl.v1beta1.TextSnippet.content)
}

// string mime_type = 2;
inline void TextSnippet::clear_mime_type() {
  mime_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TextSnippet::mime_type() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.TextSnippet.mime_type)
  return mime_type_.GetNoArena();
}
inline void TextSnippet::set_mime_type(const ::std::string& value) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.TextSnippet.mime_type)
}
#if LANG_CXX11
inline void TextSnippet::set_mime_type(::std::string&& value) {
  
  mime_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.automl.v1beta1.TextSnippet.mime_type)
}
#endif
inline void TextSnippet::set_mime_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.automl.v1beta1.TextSnippet.mime_type)
}
inline void TextSnippet::set_mime_type(const char* value, size_t size) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.automl.v1beta1.TextSnippet.mime_type)
}
inline ::std::string* TextSnippet::mutable_mime_type() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.automl.v1beta1.TextSnippet.mime_type)
  return mime_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextSnippet::release_mime_type() {
  // @@protoc_insertion_point(field_release:google.cloud.automl.v1beta1.TextSnippet.mime_type)
  
  return mime_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextSnippet::set_allocated_mime_type(::std::string* mime_type) {
  if (mime_type != NULL) {
    
  } else {
    
  }
  mime_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mime_type);
  // @@protoc_insertion_point(field_set_allocated:google.cloud.automl.v1beta1.TextSnippet.mime_type)
}

// string content_uri = 4;
inline void TextSnippet::clear_content_uri() {
  content_uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TextSnippet::content_uri() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.TextSnippet.content_uri)
  return content_uri_.GetNoArena();
}
inline void TextSnippet::set_content_uri(const ::std::string& value) {
  
  content_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.TextSnippet.content_uri)
}
#if LANG_CXX11
inline void TextSnippet::set_content_uri(::std::string&& value) {
  
  content_uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.automl.v1beta1.TextSnippet.content_uri)
}
#endif
inline void TextSnippet::set_content_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.automl.v1beta1.TextSnippet.content_uri)
}
inline void TextSnippet::set_content_uri(const char* value, size_t size) {
  
  content_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.automl.v1beta1.TextSnippet.content_uri)
}
inline ::std::string* TextSnippet::mutable_content_uri() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.automl.v1beta1.TextSnippet.content_uri)
  return content_uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextSnippet::release_content_uri() {
  // @@protoc_insertion_point(field_release:google.cloud.automl.v1beta1.TextSnippet.content_uri)
  
  return content_uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextSnippet::set_allocated_content_uri(::std::string* content_uri) {
  if (content_uri != NULL) {
    
  } else {
    
  }
  content_uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content_uri);
  // @@protoc_insertion_point(field_set_allocated:google.cloud.automl.v1beta1.TextSnippet.content_uri)
}

// -------------------------------------------------------------------

// ExamplePayload

// .google.cloud.automl.v1beta1.Image image = 1;
inline bool ExamplePayload::has_image() const {
  return payload_case() == kImage;
}
inline void ExamplePayload::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline void ExamplePayload::clear_image() {
  if (has_image()) {
    delete payload_.image_;
    clear_has_payload();
  }
}
inline const ::google::cloud::automl::v1beta1::Image& ExamplePayload::_internal_image() const {
  return *payload_.image_;
}
inline ::google::cloud::automl::v1beta1::Image* ExamplePayload::release_image() {
  // @@protoc_insertion_point(field_release:google.cloud.automl.v1beta1.ExamplePayload.image)
  if (has_image()) {
    clear_has_payload();
      ::google::cloud::automl::v1beta1::Image* temp = payload_.image_;
    payload_.image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::google::cloud::automl::v1beta1::Image& ExamplePayload::image() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ExamplePayload.image)
  return has_image()
      ? *payload_.image_
      : *reinterpret_cast< ::google::cloud::automl::v1beta1::Image*>(&::google::cloud::automl::v1beta1::_Image_default_instance_);
}
inline ::google::cloud::automl::v1beta1::Image* ExamplePayload::mutable_image() {
  if (!has_image()) {
    clear_payload();
    set_has_image();
    payload_.image_ = CreateMaybeMessage< ::google::cloud::automl::v1beta1::Image >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.automl.v1beta1.ExamplePayload.image)
  return payload_.image_;
}

// .google.cloud.automl.v1beta1.TextSnippet text_snippet = 2;
inline bool ExamplePayload::has_text_snippet() const {
  return payload_case() == kTextSnippet;
}
inline void ExamplePayload::set_has_text_snippet() {
  _oneof_case_[0] = kTextSnippet;
}
inline void ExamplePayload::clear_text_snippet() {
  if (has_text_snippet()) {
    delete payload_.text_snippet_;
    clear_has_payload();
  }
}
inline const ::google::cloud::automl::v1beta1::TextSnippet& ExamplePayload::_internal_text_snippet() const {
  return *payload_.text_snippet_;
}
inline ::google::cloud::automl::v1beta1::TextSnippet* ExamplePayload::release_text_snippet() {
  // @@protoc_insertion_point(field_release:google.cloud.automl.v1beta1.ExamplePayload.text_snippet)
  if (has_text_snippet()) {
    clear_has_payload();
      ::google::cloud::automl::v1beta1::TextSnippet* temp = payload_.text_snippet_;
    payload_.text_snippet_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::google::cloud::automl::v1beta1::TextSnippet& ExamplePayload::text_snippet() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ExamplePayload.text_snippet)
  return has_text_snippet()
      ? *payload_.text_snippet_
      : *reinterpret_cast< ::google::cloud::automl::v1beta1::TextSnippet*>(&::google::cloud::automl::v1beta1::_TextSnippet_default_instance_);
}
inline ::google::cloud::automl::v1beta1::TextSnippet* ExamplePayload::mutable_text_snippet() {
  if (!has_text_snippet()) {
    clear_payload();
    set_has_text_snippet();
    payload_.text_snippet_ = CreateMaybeMessage< ::google::cloud::automl::v1beta1::TextSnippet >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.automl.v1beta1.ExamplePayload.text_snippet)
  return payload_.text_snippet_;
}

inline bool ExamplePayload::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ExamplePayload::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ExamplePayload::PayloadCase ExamplePayload::payload_case() const {
  return ExamplePayload::PayloadCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1beta1
}  // namespace automl
}  // namespace cloud
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_google_2fcloud_2fautoml_2fv1beta1_2fdata_5fitems_2eproto
