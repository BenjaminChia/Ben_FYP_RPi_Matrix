// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/automl/v1beta1/classification.proto

#ifndef PROTOBUF_INCLUDED_google_2fcloud_2fautoml_2fv1beta1_2fclassification_2eproto
#define PROTOBUF_INCLUDED_google_2fcloud_2fautoml_2fv1beta1_2fclassification_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_google_2fcloud_2fautoml_2fv1beta1_2fclassification_2eproto 

namespace protobuf_google_2fcloud_2fautoml_2fv1beta1_2fclassification_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_google_2fcloud_2fautoml_2fv1beta1_2fclassification_2eproto
namespace google {
namespace cloud {
namespace automl {
namespace v1beta1 {
class ClassificationAnnotation;
class ClassificationAnnotationDefaultTypeInternal;
extern ClassificationAnnotationDefaultTypeInternal _ClassificationAnnotation_default_instance_;
class ClassificationEvaluationMetrics;
class ClassificationEvaluationMetricsDefaultTypeInternal;
extern ClassificationEvaluationMetricsDefaultTypeInternal _ClassificationEvaluationMetrics_default_instance_;
class ClassificationEvaluationMetrics_ConfidenceMetricsEntry;
class ClassificationEvaluationMetrics_ConfidenceMetricsEntryDefaultTypeInternal;
extern ClassificationEvaluationMetrics_ConfidenceMetricsEntryDefaultTypeInternal _ClassificationEvaluationMetrics_ConfidenceMetricsEntry_default_instance_;
class ClassificationEvaluationMetrics_ConfusionMatrix;
class ClassificationEvaluationMetrics_ConfusionMatrixDefaultTypeInternal;
extern ClassificationEvaluationMetrics_ConfusionMatrixDefaultTypeInternal _ClassificationEvaluationMetrics_ConfusionMatrix_default_instance_;
class ClassificationEvaluationMetrics_ConfusionMatrix_Row;
class ClassificationEvaluationMetrics_ConfusionMatrix_RowDefaultTypeInternal;
extern ClassificationEvaluationMetrics_ConfusionMatrix_RowDefaultTypeInternal _ClassificationEvaluationMetrics_ConfusionMatrix_Row_default_instance_;
}  // namespace v1beta1
}  // namespace automl
}  // namespace cloud
}  // namespace google
namespace google {
namespace protobuf {
template<> ::google::cloud::automl::v1beta1::ClassificationAnnotation* Arena::CreateMaybeMessage<::google::cloud::automl::v1beta1::ClassificationAnnotation>(Arena*);
template<> ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics* Arena::CreateMaybeMessage<::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics>(Arena*);
template<> ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfidenceMetricsEntry* Arena::CreateMaybeMessage<::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfidenceMetricsEntry>(Arena*);
template<> ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix* Arena::CreateMaybeMessage<::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix>(Arena*);
template<> ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix_Row* Arena::CreateMaybeMessage<::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix_Row>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace google {
namespace cloud {
namespace automl {
namespace v1beta1 {

enum ClassificationType {
  CLASSIFICATION_TYPE_UNSPECIFIED = 0,
  MULTICLASS = 1,
  MULTILABEL = 2,
  ClassificationType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ClassificationType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ClassificationType_IsValid(int value);
const ClassificationType ClassificationType_MIN = CLASSIFICATION_TYPE_UNSPECIFIED;
const ClassificationType ClassificationType_MAX = MULTILABEL;
const int ClassificationType_ARRAYSIZE = ClassificationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClassificationType_descriptor();
inline const ::std::string& ClassificationType_Name(ClassificationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClassificationType_descriptor(), value);
}
inline bool ClassificationType_Parse(
    const ::std::string& name, ClassificationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClassificationType>(
    ClassificationType_descriptor(), name, value);
}
// ===================================================================

class ClassificationAnnotation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.automl.v1beta1.ClassificationAnnotation) */ {
 public:
  ClassificationAnnotation();
  virtual ~ClassificationAnnotation();

  ClassificationAnnotation(const ClassificationAnnotation& from);

  inline ClassificationAnnotation& operator=(const ClassificationAnnotation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClassificationAnnotation(ClassificationAnnotation&& from) noexcept
    : ClassificationAnnotation() {
    *this = ::std::move(from);
  }

  inline ClassificationAnnotation& operator=(ClassificationAnnotation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClassificationAnnotation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClassificationAnnotation* internal_default_instance() {
    return reinterpret_cast<const ClassificationAnnotation*>(
               &_ClassificationAnnotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ClassificationAnnotation* other);
  friend void swap(ClassificationAnnotation& a, ClassificationAnnotation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClassificationAnnotation* New() const final {
    return CreateMaybeMessage<ClassificationAnnotation>(NULL);
  }

  ClassificationAnnotation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClassificationAnnotation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClassificationAnnotation& from);
  void MergeFrom(const ClassificationAnnotation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClassificationAnnotation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float score = 1;
  void clear_score();
  static const int kScoreFieldNumber = 1;
  float score() const;
  void set_score(float value);

  // @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.ClassificationAnnotation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float score_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fcloud_2fautoml_2fv1beta1_2fclassification_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClassificationEvaluationMetrics_ConfidenceMetricsEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry) */ {
 public:
  ClassificationEvaluationMetrics_ConfidenceMetricsEntry();
  virtual ~ClassificationEvaluationMetrics_ConfidenceMetricsEntry();

  ClassificationEvaluationMetrics_ConfidenceMetricsEntry(const ClassificationEvaluationMetrics_ConfidenceMetricsEntry& from);

  inline ClassificationEvaluationMetrics_ConfidenceMetricsEntry& operator=(const ClassificationEvaluationMetrics_ConfidenceMetricsEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClassificationEvaluationMetrics_ConfidenceMetricsEntry(ClassificationEvaluationMetrics_ConfidenceMetricsEntry&& from) noexcept
    : ClassificationEvaluationMetrics_ConfidenceMetricsEntry() {
    *this = ::std::move(from);
  }

  inline ClassificationEvaluationMetrics_ConfidenceMetricsEntry& operator=(ClassificationEvaluationMetrics_ConfidenceMetricsEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClassificationEvaluationMetrics_ConfidenceMetricsEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClassificationEvaluationMetrics_ConfidenceMetricsEntry* internal_default_instance() {
    return reinterpret_cast<const ClassificationEvaluationMetrics_ConfidenceMetricsEntry*>(
               &_ClassificationEvaluationMetrics_ConfidenceMetricsEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ClassificationEvaluationMetrics_ConfidenceMetricsEntry* other);
  friend void swap(ClassificationEvaluationMetrics_ConfidenceMetricsEntry& a, ClassificationEvaluationMetrics_ConfidenceMetricsEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClassificationEvaluationMetrics_ConfidenceMetricsEntry* New() const final {
    return CreateMaybeMessage<ClassificationEvaluationMetrics_ConfidenceMetricsEntry>(NULL);
  }

  ClassificationEvaluationMetrics_ConfidenceMetricsEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClassificationEvaluationMetrics_ConfidenceMetricsEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClassificationEvaluationMetrics_ConfidenceMetricsEntry& from);
  void MergeFrom(const ClassificationEvaluationMetrics_ConfidenceMetricsEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClassificationEvaluationMetrics_ConfidenceMetricsEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float confidence_threshold = 1;
  void clear_confidence_threshold();
  static const int kConfidenceThresholdFieldNumber = 1;
  float confidence_threshold() const;
  void set_confidence_threshold(float value);

  // float recall = 2;
  void clear_recall();
  static const int kRecallFieldNumber = 2;
  float recall() const;
  void set_recall(float value);

  // float precision = 3;
  void clear_precision();
  static const int kPrecisionFieldNumber = 3;
  float precision() const;
  void set_precision(float value);

  // float f1_score = 4;
  void clear_f1_score();
  static const int kF1ScoreFieldNumber = 4;
  float f1_score() const;
  void set_f1_score(float value);

  // float recall_at1 = 5;
  void clear_recall_at1();
  static const int kRecallAt1FieldNumber = 5;
  float recall_at1() const;
  void set_recall_at1(float value);

  // float precision_at1 = 6;
  void clear_precision_at1();
  static const int kPrecisionAt1FieldNumber = 6;
  float precision_at1() const;
  void set_precision_at1(float value);

  // float f1_score_at1 = 7;
  void clear_f1_score_at1();
  static const int kF1ScoreAt1FieldNumber = 7;
  float f1_score_at1() const;
  void set_f1_score_at1(float value);

  // @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float confidence_threshold_;
  float recall_;
  float precision_;
  float f1_score_;
  float recall_at1_;
  float precision_at1_;
  float f1_score_at1_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fcloud_2fautoml_2fv1beta1_2fclassification_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClassificationEvaluationMetrics_ConfusionMatrix_Row : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.Row) */ {
 public:
  ClassificationEvaluationMetrics_ConfusionMatrix_Row();
  virtual ~ClassificationEvaluationMetrics_ConfusionMatrix_Row();

  ClassificationEvaluationMetrics_ConfusionMatrix_Row(const ClassificationEvaluationMetrics_ConfusionMatrix_Row& from);

  inline ClassificationEvaluationMetrics_ConfusionMatrix_Row& operator=(const ClassificationEvaluationMetrics_ConfusionMatrix_Row& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClassificationEvaluationMetrics_ConfusionMatrix_Row(ClassificationEvaluationMetrics_ConfusionMatrix_Row&& from) noexcept
    : ClassificationEvaluationMetrics_ConfusionMatrix_Row() {
    *this = ::std::move(from);
  }

  inline ClassificationEvaluationMetrics_ConfusionMatrix_Row& operator=(ClassificationEvaluationMetrics_ConfusionMatrix_Row&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClassificationEvaluationMetrics_ConfusionMatrix_Row& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClassificationEvaluationMetrics_ConfusionMatrix_Row* internal_default_instance() {
    return reinterpret_cast<const ClassificationEvaluationMetrics_ConfusionMatrix_Row*>(
               &_ClassificationEvaluationMetrics_ConfusionMatrix_Row_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ClassificationEvaluationMetrics_ConfusionMatrix_Row* other);
  friend void swap(ClassificationEvaluationMetrics_ConfusionMatrix_Row& a, ClassificationEvaluationMetrics_ConfusionMatrix_Row& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClassificationEvaluationMetrics_ConfusionMatrix_Row* New() const final {
    return CreateMaybeMessage<ClassificationEvaluationMetrics_ConfusionMatrix_Row>(NULL);
  }

  ClassificationEvaluationMetrics_ConfusionMatrix_Row* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClassificationEvaluationMetrics_ConfusionMatrix_Row>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClassificationEvaluationMetrics_ConfusionMatrix_Row& from);
  void MergeFrom(const ClassificationEvaluationMetrics_ConfusionMatrix_Row& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClassificationEvaluationMetrics_ConfusionMatrix_Row* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 example_count = 1;
  int example_count_size() const;
  void clear_example_count();
  static const int kExampleCountFieldNumber = 1;
  ::google::protobuf::int32 example_count(int index) const;
  void set_example_count(int index, ::google::protobuf::int32 value);
  void add_example_count(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      example_count() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_example_count();

  // @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.Row)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > example_count_;
  mutable int _example_count_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fcloud_2fautoml_2fv1beta1_2fclassification_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClassificationEvaluationMetrics_ConfusionMatrix : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix) */ {
 public:
  ClassificationEvaluationMetrics_ConfusionMatrix();
  virtual ~ClassificationEvaluationMetrics_ConfusionMatrix();

  ClassificationEvaluationMetrics_ConfusionMatrix(const ClassificationEvaluationMetrics_ConfusionMatrix& from);

  inline ClassificationEvaluationMetrics_ConfusionMatrix& operator=(const ClassificationEvaluationMetrics_ConfusionMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClassificationEvaluationMetrics_ConfusionMatrix(ClassificationEvaluationMetrics_ConfusionMatrix&& from) noexcept
    : ClassificationEvaluationMetrics_ConfusionMatrix() {
    *this = ::std::move(from);
  }

  inline ClassificationEvaluationMetrics_ConfusionMatrix& operator=(ClassificationEvaluationMetrics_ConfusionMatrix&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClassificationEvaluationMetrics_ConfusionMatrix& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClassificationEvaluationMetrics_ConfusionMatrix* internal_default_instance() {
    return reinterpret_cast<const ClassificationEvaluationMetrics_ConfusionMatrix*>(
               &_ClassificationEvaluationMetrics_ConfusionMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ClassificationEvaluationMetrics_ConfusionMatrix* other);
  friend void swap(ClassificationEvaluationMetrics_ConfusionMatrix& a, ClassificationEvaluationMetrics_ConfusionMatrix& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClassificationEvaluationMetrics_ConfusionMatrix* New() const final {
    return CreateMaybeMessage<ClassificationEvaluationMetrics_ConfusionMatrix>(NULL);
  }

  ClassificationEvaluationMetrics_ConfusionMatrix* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClassificationEvaluationMetrics_ConfusionMatrix>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClassificationEvaluationMetrics_ConfusionMatrix& from);
  void MergeFrom(const ClassificationEvaluationMetrics_ConfusionMatrix& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClassificationEvaluationMetrics_ConfusionMatrix* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClassificationEvaluationMetrics_ConfusionMatrix_Row Row;

  // accessors -------------------------------------------------------

  // repeated string annotation_spec_id = 1;
  int annotation_spec_id_size() const;
  void clear_annotation_spec_id();
  static const int kAnnotationSpecIdFieldNumber = 1;
  const ::std::string& annotation_spec_id(int index) const;
  ::std::string* mutable_annotation_spec_id(int index);
  void set_annotation_spec_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_annotation_spec_id(int index, ::std::string&& value);
  #endif
  void set_annotation_spec_id(int index, const char* value);
  void set_annotation_spec_id(int index, const char* value, size_t size);
  ::std::string* add_annotation_spec_id();
  void add_annotation_spec_id(const ::std::string& value);
  #if LANG_CXX11
  void add_annotation_spec_id(::std::string&& value);
  #endif
  void add_annotation_spec_id(const char* value);
  void add_annotation_spec_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& annotation_spec_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_annotation_spec_id();

  // repeated .google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.Row row = 2;
  int row_size() const;
  void clear_row();
  static const int kRowFieldNumber = 2;
  ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix_Row* mutable_row(int index);
  ::google::protobuf::RepeatedPtrField< ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix_Row >*
      mutable_row();
  const ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix_Row& row(int index) const;
  ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix_Row* add_row();
  const ::google::protobuf::RepeatedPtrField< ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix_Row >&
      row() const;

  // @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> annotation_spec_id_;
  ::google::protobuf::RepeatedPtrField< ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix_Row > row_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fcloud_2fautoml_2fv1beta1_2fclassification_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClassificationEvaluationMetrics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics) */ {
 public:
  ClassificationEvaluationMetrics();
  virtual ~ClassificationEvaluationMetrics();

  ClassificationEvaluationMetrics(const ClassificationEvaluationMetrics& from);

  inline ClassificationEvaluationMetrics& operator=(const ClassificationEvaluationMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClassificationEvaluationMetrics(ClassificationEvaluationMetrics&& from) noexcept
    : ClassificationEvaluationMetrics() {
    *this = ::std::move(from);
  }

  inline ClassificationEvaluationMetrics& operator=(ClassificationEvaluationMetrics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClassificationEvaluationMetrics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClassificationEvaluationMetrics* internal_default_instance() {
    return reinterpret_cast<const ClassificationEvaluationMetrics*>(
               &_ClassificationEvaluationMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ClassificationEvaluationMetrics* other);
  friend void swap(ClassificationEvaluationMetrics& a, ClassificationEvaluationMetrics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClassificationEvaluationMetrics* New() const final {
    return CreateMaybeMessage<ClassificationEvaluationMetrics>(NULL);
  }

  ClassificationEvaluationMetrics* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClassificationEvaluationMetrics>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClassificationEvaluationMetrics& from);
  void MergeFrom(const ClassificationEvaluationMetrics& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClassificationEvaluationMetrics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClassificationEvaluationMetrics_ConfidenceMetricsEntry ConfidenceMetricsEntry;
  typedef ClassificationEvaluationMetrics_ConfusionMatrix ConfusionMatrix;

  // accessors -------------------------------------------------------

  // repeated .google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry confidence_metrics_entry = 3;
  int confidence_metrics_entry_size() const;
  void clear_confidence_metrics_entry();
  static const int kConfidenceMetricsEntryFieldNumber = 3;
  ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfidenceMetricsEntry* mutable_confidence_metrics_entry(int index);
  ::google::protobuf::RepeatedPtrField< ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfidenceMetricsEntry >*
      mutable_confidence_metrics_entry();
  const ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfidenceMetricsEntry& confidence_metrics_entry(int index) const;
  ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfidenceMetricsEntry* add_confidence_metrics_entry();
  const ::google::protobuf::RepeatedPtrField< ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfidenceMetricsEntry >&
      confidence_metrics_entry() const;

  // repeated string annotation_spec_id = 5;
  int annotation_spec_id_size() const;
  void clear_annotation_spec_id();
  static const int kAnnotationSpecIdFieldNumber = 5;
  const ::std::string& annotation_spec_id(int index) const;
  ::std::string* mutable_annotation_spec_id(int index);
  void set_annotation_spec_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_annotation_spec_id(int index, ::std::string&& value);
  #endif
  void set_annotation_spec_id(int index, const char* value);
  void set_annotation_spec_id(int index, const char* value, size_t size);
  ::std::string* add_annotation_spec_id();
  void add_annotation_spec_id(const ::std::string& value);
  #if LANG_CXX11
  void add_annotation_spec_id(::std::string&& value);
  #endif
  void add_annotation_spec_id(const char* value);
  void add_annotation_spec_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& annotation_spec_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_annotation_spec_id();

  // .google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix confusion_matrix = 4;
  bool has_confusion_matrix() const;
  void clear_confusion_matrix();
  static const int kConfusionMatrixFieldNumber = 4;
  private:
  const ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix& _internal_confusion_matrix() const;
  public:
  const ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix& confusion_matrix() const;
  ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix* release_confusion_matrix();
  ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix* mutable_confusion_matrix();
  void set_allocated_confusion_matrix(::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix* confusion_matrix);

  // float au_prc = 1;
  void clear_au_prc();
  static const int kAuPrcFieldNumber = 1;
  float au_prc() const;
  void set_au_prc(float value);

  // float base_au_prc = 2;
  void clear_base_au_prc();
  static const int kBaseAuPrcFieldNumber = 2;
  float base_au_prc() const;
  void set_base_au_prc(float value);

  // @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfidenceMetricsEntry > confidence_metrics_entry_;
  ::google::protobuf::RepeatedPtrField< ::std::string> annotation_spec_id_;
  ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix* confusion_matrix_;
  float au_prc_;
  float base_au_prc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fcloud_2fautoml_2fv1beta1_2fclassification_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ClassificationAnnotation

// float score = 1;
inline void ClassificationAnnotation::clear_score() {
  score_ = 0;
}
inline float ClassificationAnnotation::score() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationAnnotation.score)
  return score_;
}
inline void ClassificationAnnotation::set_score(float value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.ClassificationAnnotation.score)
}

// -------------------------------------------------------------------

// ClassificationEvaluationMetrics_ConfidenceMetricsEntry

// float confidence_threshold = 1;
inline void ClassificationEvaluationMetrics_ConfidenceMetricsEntry::clear_confidence_threshold() {
  confidence_threshold_ = 0;
}
inline float ClassificationEvaluationMetrics_ConfidenceMetricsEntry::confidence_threshold() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry.confidence_threshold)
  return confidence_threshold_;
}
inline void ClassificationEvaluationMetrics_ConfidenceMetricsEntry::set_confidence_threshold(float value) {
  
  confidence_threshold_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry.confidence_threshold)
}

// float recall = 2;
inline void ClassificationEvaluationMetrics_ConfidenceMetricsEntry::clear_recall() {
  recall_ = 0;
}
inline float ClassificationEvaluationMetrics_ConfidenceMetricsEntry::recall() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry.recall)
  return recall_;
}
inline void ClassificationEvaluationMetrics_ConfidenceMetricsEntry::set_recall(float value) {
  
  recall_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry.recall)
}

// float precision = 3;
inline void ClassificationEvaluationMetrics_ConfidenceMetricsEntry::clear_precision() {
  precision_ = 0;
}
inline float ClassificationEvaluationMetrics_ConfidenceMetricsEntry::precision() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry.precision)
  return precision_;
}
inline void ClassificationEvaluationMetrics_ConfidenceMetricsEntry::set_precision(float value) {
  
  precision_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry.precision)
}

// float f1_score = 4;
inline void ClassificationEvaluationMetrics_ConfidenceMetricsEntry::clear_f1_score() {
  f1_score_ = 0;
}
inline float ClassificationEvaluationMetrics_ConfidenceMetricsEntry::f1_score() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry.f1_score)
  return f1_score_;
}
inline void ClassificationEvaluationMetrics_ConfidenceMetricsEntry::set_f1_score(float value) {
  
  f1_score_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry.f1_score)
}

// float recall_at1 = 5;
inline void ClassificationEvaluationMetrics_ConfidenceMetricsEntry::clear_recall_at1() {
  recall_at1_ = 0;
}
inline float ClassificationEvaluationMetrics_ConfidenceMetricsEntry::recall_at1() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry.recall_at1)
  return recall_at1_;
}
inline void ClassificationEvaluationMetrics_ConfidenceMetricsEntry::set_recall_at1(float value) {
  
  recall_at1_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry.recall_at1)
}

// float precision_at1 = 6;
inline void ClassificationEvaluationMetrics_ConfidenceMetricsEntry::clear_precision_at1() {
  precision_at1_ = 0;
}
inline float ClassificationEvaluationMetrics_ConfidenceMetricsEntry::precision_at1() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry.precision_at1)
  return precision_at1_;
}
inline void ClassificationEvaluationMetrics_ConfidenceMetricsEntry::set_precision_at1(float value) {
  
  precision_at1_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry.precision_at1)
}

// float f1_score_at1 = 7;
inline void ClassificationEvaluationMetrics_ConfidenceMetricsEntry::clear_f1_score_at1() {
  f1_score_at1_ = 0;
}
inline float ClassificationEvaluationMetrics_ConfidenceMetricsEntry::f1_score_at1() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry.f1_score_at1)
  return f1_score_at1_;
}
inline void ClassificationEvaluationMetrics_ConfidenceMetricsEntry::set_f1_score_at1(float value) {
  
  f1_score_at1_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry.f1_score_at1)
}

// -------------------------------------------------------------------

// ClassificationEvaluationMetrics_ConfusionMatrix_Row

// repeated int32 example_count = 1;
inline int ClassificationEvaluationMetrics_ConfusionMatrix_Row::example_count_size() const {
  return example_count_.size();
}
inline void ClassificationEvaluationMetrics_ConfusionMatrix_Row::clear_example_count() {
  example_count_.Clear();
}
inline ::google::protobuf::int32 ClassificationEvaluationMetrics_ConfusionMatrix_Row::example_count(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.Row.example_count)
  return example_count_.Get(index);
}
inline void ClassificationEvaluationMetrics_ConfusionMatrix_Row::set_example_count(int index, ::google::protobuf::int32 value) {
  example_count_.Set(index, value);
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.Row.example_count)
}
inline void ClassificationEvaluationMetrics_ConfusionMatrix_Row::add_example_count(::google::protobuf::int32 value) {
  example_count_.Add(value);
  // @@protoc_insertion_point(field_add:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.Row.example_count)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ClassificationEvaluationMetrics_ConfusionMatrix_Row::example_count() const {
  // @@protoc_insertion_point(field_list:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.Row.example_count)
  return example_count_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ClassificationEvaluationMetrics_ConfusionMatrix_Row::mutable_example_count() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.Row.example_count)
  return &example_count_;
}

// -------------------------------------------------------------------

// ClassificationEvaluationMetrics_ConfusionMatrix

// repeated string annotation_spec_id = 1;
inline int ClassificationEvaluationMetrics_ConfusionMatrix::annotation_spec_id_size() const {
  return annotation_spec_id_.size();
}
inline void ClassificationEvaluationMetrics_ConfusionMatrix::clear_annotation_spec_id() {
  annotation_spec_id_.Clear();
}
inline const ::std::string& ClassificationEvaluationMetrics_ConfusionMatrix::annotation_spec_id(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.annotation_spec_id)
  return annotation_spec_id_.Get(index);
}
inline ::std::string* ClassificationEvaluationMetrics_ConfusionMatrix::mutable_annotation_spec_id(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.annotation_spec_id)
  return annotation_spec_id_.Mutable(index);
}
inline void ClassificationEvaluationMetrics_ConfusionMatrix::set_annotation_spec_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.annotation_spec_id)
  annotation_spec_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ClassificationEvaluationMetrics_ConfusionMatrix::set_annotation_spec_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.annotation_spec_id)
  annotation_spec_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ClassificationEvaluationMetrics_ConfusionMatrix::set_annotation_spec_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  annotation_spec_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.annotation_spec_id)
}
inline void ClassificationEvaluationMetrics_ConfusionMatrix::set_annotation_spec_id(int index, const char* value, size_t size) {
  annotation_spec_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.annotation_spec_id)
}
inline ::std::string* ClassificationEvaluationMetrics_ConfusionMatrix::add_annotation_spec_id() {
  // @@protoc_insertion_point(field_add_mutable:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.annotation_spec_id)
  return annotation_spec_id_.Add();
}
inline void ClassificationEvaluationMetrics_ConfusionMatrix::add_annotation_spec_id(const ::std::string& value) {
  annotation_spec_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.annotation_spec_id)
}
#if LANG_CXX11
inline void ClassificationEvaluationMetrics_ConfusionMatrix::add_annotation_spec_id(::std::string&& value) {
  annotation_spec_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.annotation_spec_id)
}
#endif
inline void ClassificationEvaluationMetrics_ConfusionMatrix::add_annotation_spec_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  annotation_spec_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.annotation_spec_id)
}
inline void ClassificationEvaluationMetrics_ConfusionMatrix::add_annotation_spec_id(const char* value, size_t size) {
  annotation_spec_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.annotation_spec_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClassificationEvaluationMetrics_ConfusionMatrix::annotation_spec_id() const {
  // @@protoc_insertion_point(field_list:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.annotation_spec_id)
  return annotation_spec_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClassificationEvaluationMetrics_ConfusionMatrix::mutable_annotation_spec_id() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.annotation_spec_id)
  return &annotation_spec_id_;
}

// repeated .google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.Row row = 2;
inline int ClassificationEvaluationMetrics_ConfusionMatrix::row_size() const {
  return row_.size();
}
inline void ClassificationEvaluationMetrics_ConfusionMatrix::clear_row() {
  row_.Clear();
}
inline ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix_Row* ClassificationEvaluationMetrics_ConfusionMatrix::mutable_row(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.row)
  return row_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix_Row >*
ClassificationEvaluationMetrics_ConfusionMatrix::mutable_row() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.row)
  return &row_;
}
inline const ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix_Row& ClassificationEvaluationMetrics_ConfusionMatrix::row(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.row)
  return row_.Get(index);
}
inline ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix_Row* ClassificationEvaluationMetrics_ConfusionMatrix::add_row() {
  // @@protoc_insertion_point(field_add:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.row)
  return row_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix_Row >&
ClassificationEvaluationMetrics_ConfusionMatrix::row() const {
  // @@protoc_insertion_point(field_list:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix.row)
  return row_;
}

// -------------------------------------------------------------------

// ClassificationEvaluationMetrics

// float au_prc = 1;
inline void ClassificationEvaluationMetrics::clear_au_prc() {
  au_prc_ = 0;
}
inline float ClassificationEvaluationMetrics::au_prc() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.au_prc)
  return au_prc_;
}
inline void ClassificationEvaluationMetrics::set_au_prc(float value) {
  
  au_prc_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.au_prc)
}

// float base_au_prc = 2;
inline void ClassificationEvaluationMetrics::clear_base_au_prc() {
  base_au_prc_ = 0;
}
inline float ClassificationEvaluationMetrics::base_au_prc() const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.base_au_prc)
  return base_au_prc_;
}
inline void ClassificationEvaluationMetrics::set_base_au_prc(float value) {
  
  base_au_prc_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.base_au_prc)
}

// repeated .google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfidenceMetricsEntry confidence_metrics_entry = 3;
inline int ClassificationEvaluationMetrics::confidence_metrics_entry_size() const {
  return confidence_metrics_entry_.size();
}
inline void ClassificationEvaluationMetrics::clear_confidence_metrics_entry() {
  confidence_metrics_entry_.Clear();
}
inline ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfidenceMetricsEntry* ClassificationEvaluationMetrics::mutable_confidence_metrics_entry(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.confidence_metrics_entry)
  return confidence_metrics_entry_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfidenceMetricsEntry >*
ClassificationEvaluationMetrics::mutable_confidence_metrics_entry() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.confidence_metrics_entry)
  return &confidence_metrics_entry_;
}
inline const ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfidenceMetricsEntry& ClassificationEvaluationMetrics::confidence_metrics_entry(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.confidence_metrics_entry)
  return confidence_metrics_entry_.Get(index);
}
inline ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfidenceMetricsEntry* ClassificationEvaluationMetrics::add_confidence_metrics_entry() {
  // @@protoc_insertion_point(field_add:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.confidence_metrics_entry)
  return confidence_metrics_entry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfidenceMetricsEntry >&
ClassificationEvaluationMetrics::confidence_metrics_entry() const {
  // @@protoc_insertion_point(field_list:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.confidence_metrics_entry)
  return confidence_metrics_entry_;
}

// .google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.ConfusionMatrix confusion_matrix = 4;
inline bool ClassificationEvaluationMetrics::has_confusion_matrix() const {
  return this != internal_default_instance() && confusion_matrix_ != NULL;
}
inline void ClassificationEvaluationMetrics::clear_confusion_matrix() {
  if (GetArenaNoVirtual() == NULL && confusion_matrix_ != NULL) {
    delete confusion_matrix_;
  }
  confusion_matrix_ = NULL;
}
inline const ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix& ClassificationEvaluationMetrics::_internal_confusion_matrix() const {
  return *confusion_matrix_;
}
inline const ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix& ClassificationEvaluationMetrics::confusion_matrix() const {
  const ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix* p = confusion_matrix_;
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.confusion_matrix)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix*>(
      &::google::cloud::automl::v1beta1::_ClassificationEvaluationMetrics_ConfusionMatrix_default_instance_);
}
inline ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix* ClassificationEvaluationMetrics::release_confusion_matrix() {
  // @@protoc_insertion_point(field_release:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.confusion_matrix)
  
  ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix* temp = confusion_matrix_;
  confusion_matrix_ = NULL;
  return temp;
}
inline ::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix* ClassificationEvaluationMetrics::mutable_confusion_matrix() {
  
  if (confusion_matrix_ == NULL) {
    auto* p = CreateMaybeMessage<::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix>(GetArenaNoVirtual());
    confusion_matrix_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.confusion_matrix)
  return confusion_matrix_;
}
inline void ClassificationEvaluationMetrics::set_allocated_confusion_matrix(::google::cloud::automl::v1beta1::ClassificationEvaluationMetrics_ConfusionMatrix* confusion_matrix) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete confusion_matrix_;
  }
  if (confusion_matrix) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      confusion_matrix = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confusion_matrix, submessage_arena);
    }
    
  } else {
    
  }
  confusion_matrix_ = confusion_matrix;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.confusion_matrix)
}

// repeated string annotation_spec_id = 5;
inline int ClassificationEvaluationMetrics::annotation_spec_id_size() const {
  return annotation_spec_id_.size();
}
inline void ClassificationEvaluationMetrics::clear_annotation_spec_id() {
  annotation_spec_id_.Clear();
}
inline const ::std::string& ClassificationEvaluationMetrics::annotation_spec_id(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.annotation_spec_id)
  return annotation_spec_id_.Get(index);
}
inline ::std::string* ClassificationEvaluationMetrics::mutable_annotation_spec_id(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.annotation_spec_id)
  return annotation_spec_id_.Mutable(index);
}
inline void ClassificationEvaluationMetrics::set_annotation_spec_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.annotation_spec_id)
  annotation_spec_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ClassificationEvaluationMetrics::set_annotation_spec_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.annotation_spec_id)
  annotation_spec_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ClassificationEvaluationMetrics::set_annotation_spec_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  annotation_spec_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.annotation_spec_id)
}
inline void ClassificationEvaluationMetrics::set_annotation_spec_id(int index, const char* value, size_t size) {
  annotation_spec_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.annotation_spec_id)
}
inline ::std::string* ClassificationEvaluationMetrics::add_annotation_spec_id() {
  // @@protoc_insertion_point(field_add_mutable:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.annotation_spec_id)
  return annotation_spec_id_.Add();
}
inline void ClassificationEvaluationMetrics::add_annotation_spec_id(const ::std::string& value) {
  annotation_spec_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.annotation_spec_id)
}
#if LANG_CXX11
inline void ClassificationEvaluationMetrics::add_annotation_spec_id(::std::string&& value) {
  annotation_spec_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.annotation_spec_id)
}
#endif
inline void ClassificationEvaluationMetrics::add_annotation_spec_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  annotation_spec_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.annotation_spec_id)
}
inline void ClassificationEvaluationMetrics::add_annotation_spec_id(const char* value, size_t size) {
  annotation_spec_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.annotation_spec_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClassificationEvaluationMetrics::annotation_spec_id() const {
  // @@protoc_insertion_point(field_list:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.annotation_spec_id)
  return annotation_spec_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClassificationEvaluationMetrics::mutable_annotation_spec_id() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.automl.v1beta1.ClassificationEvaluationMetrics.annotation_spec_id)
  return &annotation_spec_id_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1beta1
}  // namespace automl
}  // namespace cloud
}  // namespace google

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::google::cloud::automl::v1beta1::ClassificationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::automl::v1beta1::ClassificationType>() {
  return ::google::cloud::automl::v1beta1::ClassificationType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_google_2fcloud_2fautoml_2fv1beta1_2fclassification_2eproto
