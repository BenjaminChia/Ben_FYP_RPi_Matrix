// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/devtools/containeranalysis/v1alpha1/package_vulnerability.proto

#ifndef PROTOBUF_INCLUDED_google_2fdevtools_2fcontaineranalysis_2fv1alpha1_2fpackage_5fvulnerability_2eproto
#define PROTOBUF_INCLUDED_google_2fdevtools_2fcontaineranalysis_2fv1alpha1_2fpackage_5fvulnerability_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_google_2fdevtools_2fcontaineranalysis_2fv1alpha1_2fpackage_5fvulnerability_2eproto 

namespace protobuf_google_2fdevtools_2fcontaineranalysis_2fv1alpha1_2fpackage_5fvulnerability_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_google_2fdevtools_2fcontaineranalysis_2fv1alpha1_2fpackage_5fvulnerability_2eproto
namespace google {
namespace devtools {
namespace containeranalysis {
namespace v1alpha1 {
class VulnerabilityType;
class VulnerabilityTypeDefaultTypeInternal;
extern VulnerabilityTypeDefaultTypeInternal _VulnerabilityType_default_instance_;
class VulnerabilityType_Detail;
class VulnerabilityType_DetailDefaultTypeInternal;
extern VulnerabilityType_DetailDefaultTypeInternal _VulnerabilityType_Detail_default_instance_;
class VulnerabilityType_PackageIssue;
class VulnerabilityType_PackageIssueDefaultTypeInternal;
extern VulnerabilityType_PackageIssueDefaultTypeInternal _VulnerabilityType_PackageIssue_default_instance_;
class VulnerabilityType_Version;
class VulnerabilityType_VersionDefaultTypeInternal;
extern VulnerabilityType_VersionDefaultTypeInternal _VulnerabilityType_Version_default_instance_;
class VulnerabilityType_VulnerabilityDetails;
class VulnerabilityType_VulnerabilityDetailsDefaultTypeInternal;
extern VulnerabilityType_VulnerabilityDetailsDefaultTypeInternal _VulnerabilityType_VulnerabilityDetails_default_instance_;
class VulnerabilityType_VulnerabilityLocation;
class VulnerabilityType_VulnerabilityLocationDefaultTypeInternal;
extern VulnerabilityType_VulnerabilityLocationDefaultTypeInternal _VulnerabilityType_VulnerabilityLocation_default_instance_;
}  // namespace v1alpha1
}  // namespace containeranalysis
}  // namespace devtools
}  // namespace google
namespace google {
namespace protobuf {
template<> ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType* Arena::CreateMaybeMessage<::google::devtools::containeranalysis::v1alpha1::VulnerabilityType>(Arena*);
template<> ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Detail* Arena::CreateMaybeMessage<::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Detail>(Arena*);
template<> ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_PackageIssue* Arena::CreateMaybeMessage<::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_PackageIssue>(Arena*);
template<> ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* Arena::CreateMaybeMessage<::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version>(Arena*);
template<> ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityDetails* Arena::CreateMaybeMessage<::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityDetails>(Arena*);
template<> ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* Arena::CreateMaybeMessage<::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace google {
namespace devtools {
namespace containeranalysis {
namespace v1alpha1 {

enum VulnerabilityType_Version_VersionKind {
  VulnerabilityType_Version_VersionKind_NORMAL = 0,
  VulnerabilityType_Version_VersionKind_MINIMUM = 1,
  VulnerabilityType_Version_VersionKind_MAXIMUM = 2,
  VulnerabilityType_Version_VersionKind_VulnerabilityType_Version_VersionKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VulnerabilityType_Version_VersionKind_VulnerabilityType_Version_VersionKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VulnerabilityType_Version_VersionKind_IsValid(int value);
const VulnerabilityType_Version_VersionKind VulnerabilityType_Version_VersionKind_VersionKind_MIN = VulnerabilityType_Version_VersionKind_NORMAL;
const VulnerabilityType_Version_VersionKind VulnerabilityType_Version_VersionKind_VersionKind_MAX = VulnerabilityType_Version_VersionKind_MAXIMUM;
const int VulnerabilityType_Version_VersionKind_VersionKind_ARRAYSIZE = VulnerabilityType_Version_VersionKind_VersionKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* VulnerabilityType_Version_VersionKind_descriptor();
inline const ::std::string& VulnerabilityType_Version_VersionKind_Name(VulnerabilityType_Version_VersionKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    VulnerabilityType_Version_VersionKind_descriptor(), value);
}
inline bool VulnerabilityType_Version_VersionKind_Parse(
    const ::std::string& name, VulnerabilityType_Version_VersionKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VulnerabilityType_Version_VersionKind>(
    VulnerabilityType_Version_VersionKind_descriptor(), name, value);
}
enum VulnerabilityType_Severity {
  VulnerabilityType_Severity_SEVERITY_UNSPECIFIED = 0,
  VulnerabilityType_Severity_MINIMAL = 1,
  VulnerabilityType_Severity_LOW = 2,
  VulnerabilityType_Severity_MEDIUM = 3,
  VulnerabilityType_Severity_HIGH = 4,
  VulnerabilityType_Severity_CRITICAL = 5,
  VulnerabilityType_Severity_VulnerabilityType_Severity_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VulnerabilityType_Severity_VulnerabilityType_Severity_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VulnerabilityType_Severity_IsValid(int value);
const VulnerabilityType_Severity VulnerabilityType_Severity_Severity_MIN = VulnerabilityType_Severity_SEVERITY_UNSPECIFIED;
const VulnerabilityType_Severity VulnerabilityType_Severity_Severity_MAX = VulnerabilityType_Severity_CRITICAL;
const int VulnerabilityType_Severity_Severity_ARRAYSIZE = VulnerabilityType_Severity_Severity_MAX + 1;

const ::google::protobuf::EnumDescriptor* VulnerabilityType_Severity_descriptor();
inline const ::std::string& VulnerabilityType_Severity_Name(VulnerabilityType_Severity value) {
  return ::google::protobuf::internal::NameOfEnum(
    VulnerabilityType_Severity_descriptor(), value);
}
inline bool VulnerabilityType_Severity_Parse(
    const ::std::string& name, VulnerabilityType_Severity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VulnerabilityType_Severity>(
    VulnerabilityType_Severity_descriptor(), name, value);
}
// ===================================================================

class VulnerabilityType_Version : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version) */ {
 public:
  VulnerabilityType_Version();
  virtual ~VulnerabilityType_Version();

  VulnerabilityType_Version(const VulnerabilityType_Version& from);

  inline VulnerabilityType_Version& operator=(const VulnerabilityType_Version& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VulnerabilityType_Version(VulnerabilityType_Version&& from) noexcept
    : VulnerabilityType_Version() {
    *this = ::std::move(from);
  }

  inline VulnerabilityType_Version& operator=(VulnerabilityType_Version&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VulnerabilityType_Version& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VulnerabilityType_Version* internal_default_instance() {
    return reinterpret_cast<const VulnerabilityType_Version*>(
               &_VulnerabilityType_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(VulnerabilityType_Version* other);
  friend void swap(VulnerabilityType_Version& a, VulnerabilityType_Version& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VulnerabilityType_Version* New() const final {
    return CreateMaybeMessage<VulnerabilityType_Version>(NULL);
  }

  VulnerabilityType_Version* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VulnerabilityType_Version>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VulnerabilityType_Version& from);
  void MergeFrom(const VulnerabilityType_Version& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VulnerabilityType_Version* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VulnerabilityType_Version_VersionKind VersionKind;
  static const VersionKind NORMAL =
    VulnerabilityType_Version_VersionKind_NORMAL;
  static const VersionKind MINIMUM =
    VulnerabilityType_Version_VersionKind_MINIMUM;
  static const VersionKind MAXIMUM =
    VulnerabilityType_Version_VersionKind_MAXIMUM;
  static inline bool VersionKind_IsValid(int value) {
    return VulnerabilityType_Version_VersionKind_IsValid(value);
  }
  static const VersionKind VersionKind_MIN =
    VulnerabilityType_Version_VersionKind_VersionKind_MIN;
  static const VersionKind VersionKind_MAX =
    VulnerabilityType_Version_VersionKind_VersionKind_MAX;
  static const int VersionKind_ARRAYSIZE =
    VulnerabilityType_Version_VersionKind_VersionKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VersionKind_descriptor() {
    return VulnerabilityType_Version_VersionKind_descriptor();
  }
  static inline const ::std::string& VersionKind_Name(VersionKind value) {
    return VulnerabilityType_Version_VersionKind_Name(value);
  }
  static inline bool VersionKind_Parse(const ::std::string& name,
      VersionKind* value) {
    return VulnerabilityType_Version_VersionKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string revision = 3;
  void clear_revision();
  static const int kRevisionFieldNumber = 3;
  const ::std::string& revision() const;
  void set_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_revision(::std::string&& value);
  #endif
  void set_revision(const char* value);
  void set_revision(const char* value, size_t size);
  ::std::string* mutable_revision();
  ::std::string* release_revision();
  void set_allocated_revision(::std::string* revision);

  // int32 epoch = 1;
  void clear_epoch();
  static const int kEpochFieldNumber = 1;
  ::google::protobuf::int32 epoch() const;
  void set_epoch(::google::protobuf::int32 value);

  // .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.VersionKind kind = 5;
  void clear_kind();
  static const int kKindFieldNumber = 5;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version_VersionKind kind() const;
  void set_kind(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version_VersionKind value);

  // @@protoc_insertion_point(class_scope:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr revision_;
  ::google::protobuf::int32 epoch_;
  int kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fdevtools_2fcontaineranalysis_2fv1alpha1_2fpackage_5fvulnerability_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VulnerabilityType_Detail : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail) */ {
 public:
  VulnerabilityType_Detail();
  virtual ~VulnerabilityType_Detail();

  VulnerabilityType_Detail(const VulnerabilityType_Detail& from);

  inline VulnerabilityType_Detail& operator=(const VulnerabilityType_Detail& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VulnerabilityType_Detail(VulnerabilityType_Detail&& from) noexcept
    : VulnerabilityType_Detail() {
    *this = ::std::move(from);
  }

  inline VulnerabilityType_Detail& operator=(VulnerabilityType_Detail&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VulnerabilityType_Detail& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VulnerabilityType_Detail* internal_default_instance() {
    return reinterpret_cast<const VulnerabilityType_Detail*>(
               &_VulnerabilityType_Detail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(VulnerabilityType_Detail* other);
  friend void swap(VulnerabilityType_Detail& a, VulnerabilityType_Detail& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VulnerabilityType_Detail* New() const final {
    return CreateMaybeMessage<VulnerabilityType_Detail>(NULL);
  }

  VulnerabilityType_Detail* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VulnerabilityType_Detail>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VulnerabilityType_Detail& from);
  void MergeFrom(const VulnerabilityType_Detail& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VulnerabilityType_Detail* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cpe_uri = 1;
  void clear_cpe_uri();
  static const int kCpeUriFieldNumber = 1;
  const ::std::string& cpe_uri() const;
  void set_cpe_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_cpe_uri(::std::string&& value);
  #endif
  void set_cpe_uri(const char* value);
  void set_cpe_uri(const char* value, size_t size);
  ::std::string* mutable_cpe_uri();
  ::std::string* release_cpe_uri();
  void set_allocated_cpe_uri(::std::string* cpe_uri);

  // string severity_name = 4;
  void clear_severity_name();
  static const int kSeverityNameFieldNumber = 4;
  const ::std::string& severity_name() const;
  void set_severity_name(const ::std::string& value);
  #if LANG_CXX11
  void set_severity_name(::std::string&& value);
  #endif
  void set_severity_name(const char* value);
  void set_severity_name(const char* value, size_t size);
  ::std::string* mutable_severity_name();
  ::std::string* release_severity_name();
  void set_allocated_severity_name(::std::string* severity_name);

  // string package = 8;
  void clear_package();
  static const int kPackageFieldNumber = 8;
  const ::std::string& package() const;
  void set_package(const ::std::string& value);
  #if LANG_CXX11
  void set_package(::std::string&& value);
  #endif
  void set_package(const char* value);
  void set_package(const char* value, size_t size);
  ::std::string* mutable_package();
  ::std::string* release_package();
  void set_allocated_package(::std::string* package);

  // string description = 9;
  void clear_description();
  static const int kDescriptionFieldNumber = 9;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string package_type = 10;
  void clear_package_type();
  static const int kPackageTypeFieldNumber = 10;
  const ::std::string& package_type() const;
  void set_package_type(const ::std::string& value);
  #if LANG_CXX11
  void set_package_type(::std::string&& value);
  #endif
  void set_package_type(const char* value);
  void set_package_type(const char* value, size_t size);
  ::std::string* mutable_package_type();
  ::std::string* release_package_type();
  void set_allocated_package_type(::std::string* package_type);

  // .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation fixed_location = 5;
  bool has_fixed_location() const;
  void clear_fixed_location();
  static const int kFixedLocationFieldNumber = 5;
  private:
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation& _internal_fixed_location() const;
  public:
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation& fixed_location() const;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* release_fixed_location();
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* mutable_fixed_location();
  void set_allocated_fixed_location(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* fixed_location);

  // .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version min_affected_version = 6;
  bool has_min_affected_version() const;
  void clear_min_affected_version();
  static const int kMinAffectedVersionFieldNumber = 6;
  private:
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version& _internal_min_affected_version() const;
  public:
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version& min_affected_version() const;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* release_min_affected_version();
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* mutable_min_affected_version();
  void set_allocated_min_affected_version(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* min_affected_version);

  // .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version max_affected_version = 7;
  bool has_max_affected_version() const;
  void clear_max_affected_version();
  static const int kMaxAffectedVersionFieldNumber = 7;
  private:
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version& _internal_max_affected_version() const;
  public:
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version& max_affected_version() const;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* release_max_affected_version();
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* mutable_max_affected_version();
  void set_allocated_max_affected_version(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* max_affected_version);

  // bool is_obsolete = 11;
  void clear_is_obsolete();
  static const int kIsObsoleteFieldNumber = 11;
  bool is_obsolete() const;
  void set_is_obsolete(bool value);

  // @@protoc_insertion_point(class_scope:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cpe_uri_;
  ::google::protobuf::internal::ArenaStringPtr severity_name_;
  ::google::protobuf::internal::ArenaStringPtr package_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr package_type_;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* fixed_location_;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* min_affected_version_;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* max_affected_version_;
  bool is_obsolete_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fdevtools_2fcontaineranalysis_2fv1alpha1_2fpackage_5fvulnerability_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VulnerabilityType_VulnerabilityDetails : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails) */ {
 public:
  VulnerabilityType_VulnerabilityDetails();
  virtual ~VulnerabilityType_VulnerabilityDetails();

  VulnerabilityType_VulnerabilityDetails(const VulnerabilityType_VulnerabilityDetails& from);

  inline VulnerabilityType_VulnerabilityDetails& operator=(const VulnerabilityType_VulnerabilityDetails& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VulnerabilityType_VulnerabilityDetails(VulnerabilityType_VulnerabilityDetails&& from) noexcept
    : VulnerabilityType_VulnerabilityDetails() {
    *this = ::std::move(from);
  }

  inline VulnerabilityType_VulnerabilityDetails& operator=(VulnerabilityType_VulnerabilityDetails&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VulnerabilityType_VulnerabilityDetails& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VulnerabilityType_VulnerabilityDetails* internal_default_instance() {
    return reinterpret_cast<const VulnerabilityType_VulnerabilityDetails*>(
               &_VulnerabilityType_VulnerabilityDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(VulnerabilityType_VulnerabilityDetails* other);
  friend void swap(VulnerabilityType_VulnerabilityDetails& a, VulnerabilityType_VulnerabilityDetails& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VulnerabilityType_VulnerabilityDetails* New() const final {
    return CreateMaybeMessage<VulnerabilityType_VulnerabilityDetails>(NULL);
  }

  VulnerabilityType_VulnerabilityDetails* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VulnerabilityType_VulnerabilityDetails>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VulnerabilityType_VulnerabilityDetails& from);
  void MergeFrom(const VulnerabilityType_VulnerabilityDetails& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VulnerabilityType_VulnerabilityDetails* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue package_issue = 6;
  int package_issue_size() const;
  void clear_package_issue();
  static const int kPackageIssueFieldNumber = 6;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_PackageIssue* mutable_package_issue(int index);
  ::google::protobuf::RepeatedPtrField< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_PackageIssue >*
      mutable_package_issue();
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_PackageIssue& package_issue(int index) const;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_PackageIssue* add_package_issue();
  const ::google::protobuf::RepeatedPtrField< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_PackageIssue >&
      package_issue() const;

  // string type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Severity severity = 4;
  void clear_severity();
  static const int kSeverityFieldNumber = 4;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Severity severity() const;
  void set_severity(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Severity value);

  // float cvss_score = 5;
  void clear_cvss_score();
  static const int kCvssScoreFieldNumber = 5;
  float cvss_score() const;
  void set_cvss_score(float value);

  // @@protoc_insertion_point(class_scope:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_PackageIssue > package_issue_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  int severity_;
  float cvss_score_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fdevtools_2fcontaineranalysis_2fv1alpha1_2fpackage_5fvulnerability_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VulnerabilityType_PackageIssue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue) */ {
 public:
  VulnerabilityType_PackageIssue();
  virtual ~VulnerabilityType_PackageIssue();

  VulnerabilityType_PackageIssue(const VulnerabilityType_PackageIssue& from);

  inline VulnerabilityType_PackageIssue& operator=(const VulnerabilityType_PackageIssue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VulnerabilityType_PackageIssue(VulnerabilityType_PackageIssue&& from) noexcept
    : VulnerabilityType_PackageIssue() {
    *this = ::std::move(from);
  }

  inline VulnerabilityType_PackageIssue& operator=(VulnerabilityType_PackageIssue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VulnerabilityType_PackageIssue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VulnerabilityType_PackageIssue* internal_default_instance() {
    return reinterpret_cast<const VulnerabilityType_PackageIssue*>(
               &_VulnerabilityType_PackageIssue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(VulnerabilityType_PackageIssue* other);
  friend void swap(VulnerabilityType_PackageIssue& a, VulnerabilityType_PackageIssue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VulnerabilityType_PackageIssue* New() const final {
    return CreateMaybeMessage<VulnerabilityType_PackageIssue>(NULL);
  }

  VulnerabilityType_PackageIssue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VulnerabilityType_PackageIssue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VulnerabilityType_PackageIssue& from);
  void MergeFrom(const VulnerabilityType_PackageIssue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VulnerabilityType_PackageIssue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string severity_name = 3;
  void clear_severity_name();
  static const int kSeverityNameFieldNumber = 3;
  const ::std::string& severity_name() const;
  void set_severity_name(const ::std::string& value);
  #if LANG_CXX11
  void set_severity_name(::std::string&& value);
  #endif
  void set_severity_name(const char* value);
  void set_severity_name(const char* value, size_t size);
  ::std::string* mutable_severity_name();
  ::std::string* release_severity_name();
  void set_allocated_severity_name(::std::string* severity_name);

  // .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation affected_location = 1;
  bool has_affected_location() const;
  void clear_affected_location();
  static const int kAffectedLocationFieldNumber = 1;
  private:
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation& _internal_affected_location() const;
  public:
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation& affected_location() const;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* release_affected_location();
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* mutable_affected_location();
  void set_allocated_affected_location(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* affected_location);

  // .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation fixed_location = 2;
  bool has_fixed_location() const;
  void clear_fixed_location();
  static const int kFixedLocationFieldNumber = 2;
  private:
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation& _internal_fixed_location() const;
  public:
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation& fixed_location() const;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* release_fixed_location();
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* mutable_fixed_location();
  void set_allocated_fixed_location(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* fixed_location);

  // @@protoc_insertion_point(class_scope:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr severity_name_;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* affected_location_;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* fixed_location_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fdevtools_2fcontaineranalysis_2fv1alpha1_2fpackage_5fvulnerability_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VulnerabilityType_VulnerabilityLocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation) */ {
 public:
  VulnerabilityType_VulnerabilityLocation();
  virtual ~VulnerabilityType_VulnerabilityLocation();

  VulnerabilityType_VulnerabilityLocation(const VulnerabilityType_VulnerabilityLocation& from);

  inline VulnerabilityType_VulnerabilityLocation& operator=(const VulnerabilityType_VulnerabilityLocation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VulnerabilityType_VulnerabilityLocation(VulnerabilityType_VulnerabilityLocation&& from) noexcept
    : VulnerabilityType_VulnerabilityLocation() {
    *this = ::std::move(from);
  }

  inline VulnerabilityType_VulnerabilityLocation& operator=(VulnerabilityType_VulnerabilityLocation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VulnerabilityType_VulnerabilityLocation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VulnerabilityType_VulnerabilityLocation* internal_default_instance() {
    return reinterpret_cast<const VulnerabilityType_VulnerabilityLocation*>(
               &_VulnerabilityType_VulnerabilityLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(VulnerabilityType_VulnerabilityLocation* other);
  friend void swap(VulnerabilityType_VulnerabilityLocation& a, VulnerabilityType_VulnerabilityLocation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VulnerabilityType_VulnerabilityLocation* New() const final {
    return CreateMaybeMessage<VulnerabilityType_VulnerabilityLocation>(NULL);
  }

  VulnerabilityType_VulnerabilityLocation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VulnerabilityType_VulnerabilityLocation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VulnerabilityType_VulnerabilityLocation& from);
  void MergeFrom(const VulnerabilityType_VulnerabilityLocation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VulnerabilityType_VulnerabilityLocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cpe_uri = 1;
  void clear_cpe_uri();
  static const int kCpeUriFieldNumber = 1;
  const ::std::string& cpe_uri() const;
  void set_cpe_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_cpe_uri(::std::string&& value);
  #endif
  void set_cpe_uri(const char* value);
  void set_cpe_uri(const char* value, size_t size);
  ::std::string* mutable_cpe_uri();
  ::std::string* release_cpe_uri();
  void set_allocated_cpe_uri(::std::string* cpe_uri);

  // string package = 2;
  void clear_package();
  static const int kPackageFieldNumber = 2;
  const ::std::string& package() const;
  void set_package(const ::std::string& value);
  #if LANG_CXX11
  void set_package(::std::string&& value);
  #endif
  void set_package(const char* value);
  void set_package(const char* value, size_t size);
  ::std::string* mutable_package();
  ::std::string* release_package();
  void set_allocated_package(::std::string* package);

  // .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version version = 4;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  private:
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version& _internal_version() const;
  public:
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version& version() const;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* release_version();
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* mutable_version();
  void set_allocated_version(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* version);

  // @@protoc_insertion_point(class_scope:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cpe_uri_;
  ::google::protobuf::internal::ArenaStringPtr package_;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fdevtools_2fcontaineranalysis_2fv1alpha1_2fpackage_5fvulnerability_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VulnerabilityType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.devtools.containeranalysis.v1alpha1.VulnerabilityType) */ {
 public:
  VulnerabilityType();
  virtual ~VulnerabilityType();

  VulnerabilityType(const VulnerabilityType& from);

  inline VulnerabilityType& operator=(const VulnerabilityType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VulnerabilityType(VulnerabilityType&& from) noexcept
    : VulnerabilityType() {
    *this = ::std::move(from);
  }

  inline VulnerabilityType& operator=(VulnerabilityType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VulnerabilityType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VulnerabilityType* internal_default_instance() {
    return reinterpret_cast<const VulnerabilityType*>(
               &_VulnerabilityType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(VulnerabilityType* other);
  friend void swap(VulnerabilityType& a, VulnerabilityType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VulnerabilityType* New() const final {
    return CreateMaybeMessage<VulnerabilityType>(NULL);
  }

  VulnerabilityType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VulnerabilityType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VulnerabilityType& from);
  void MergeFrom(const VulnerabilityType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VulnerabilityType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VulnerabilityType_Version Version;
  typedef VulnerabilityType_Detail Detail;
  typedef VulnerabilityType_VulnerabilityDetails VulnerabilityDetails;
  typedef VulnerabilityType_PackageIssue PackageIssue;
  typedef VulnerabilityType_VulnerabilityLocation VulnerabilityLocation;

  typedef VulnerabilityType_Severity Severity;
  static const Severity SEVERITY_UNSPECIFIED =
    VulnerabilityType_Severity_SEVERITY_UNSPECIFIED;
  static const Severity MINIMAL =
    VulnerabilityType_Severity_MINIMAL;
  static const Severity LOW =
    VulnerabilityType_Severity_LOW;
  static const Severity MEDIUM =
    VulnerabilityType_Severity_MEDIUM;
  static const Severity HIGH =
    VulnerabilityType_Severity_HIGH;
  static const Severity CRITICAL =
    VulnerabilityType_Severity_CRITICAL;
  static inline bool Severity_IsValid(int value) {
    return VulnerabilityType_Severity_IsValid(value);
  }
  static const Severity Severity_MIN =
    VulnerabilityType_Severity_Severity_MIN;
  static const Severity Severity_MAX =
    VulnerabilityType_Severity_Severity_MAX;
  static const int Severity_ARRAYSIZE =
    VulnerabilityType_Severity_Severity_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Severity_descriptor() {
    return VulnerabilityType_Severity_descriptor();
  }
  static inline const ::std::string& Severity_Name(Severity value) {
    return VulnerabilityType_Severity_Name(value);
  }
  static inline bool Severity_Parse(const ::std::string& name,
      Severity* value) {
    return VulnerabilityType_Severity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail details = 4;
  int details_size() const;
  void clear_details();
  static const int kDetailsFieldNumber = 4;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Detail* mutable_details(int index);
  ::google::protobuf::RepeatedPtrField< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Detail >*
      mutable_details();
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Detail& details(int index) const;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Detail* add_details();
  const ::google::protobuf::RepeatedPtrField< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Detail >&
      details() const;

  // float cvss_score = 2;
  void clear_cvss_score();
  static const int kCvssScoreFieldNumber = 2;
  float cvss_score() const;
  void set_cvss_score(float value);

  // .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Severity severity = 3;
  void clear_severity();
  static const int kSeverityFieldNumber = 3;
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Severity severity() const;
  void set_severity(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Severity value);

  // @@protoc_insertion_point(class_scope:google.devtools.containeranalysis.v1alpha1.VulnerabilityType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Detail > details_;
  float cvss_score_;
  int severity_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fdevtools_2fcontaineranalysis_2fv1alpha1_2fpackage_5fvulnerability_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VulnerabilityType_Version

// int32 epoch = 1;
inline void VulnerabilityType_Version::clear_epoch() {
  epoch_ = 0;
}
inline ::google::protobuf::int32 VulnerabilityType_Version::epoch() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.epoch)
  return epoch_;
}
inline void VulnerabilityType_Version::set_epoch(::google::protobuf::int32 value) {
  
  epoch_ = value;
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.epoch)
}

// string name = 2;
inline void VulnerabilityType_Version::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VulnerabilityType_Version::name() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.name)
  return name_.GetNoArena();
}
inline void VulnerabilityType_Version::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.name)
}
#if LANG_CXX11
inline void VulnerabilityType_Version::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.name)
}
#endif
inline void VulnerabilityType_Version::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.name)
}
inline void VulnerabilityType_Version::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.name)
}
inline ::std::string* VulnerabilityType_Version::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VulnerabilityType_Version::release_name() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VulnerabilityType_Version::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.name)
}

// string revision = 3;
inline void VulnerabilityType_Version::clear_revision() {
  revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VulnerabilityType_Version::revision() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.revision)
  return revision_.GetNoArena();
}
inline void VulnerabilityType_Version::set_revision(const ::std::string& value) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.revision)
}
#if LANG_CXX11
inline void VulnerabilityType_Version::set_revision(::std::string&& value) {
  
  revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.revision)
}
#endif
inline void VulnerabilityType_Version::set_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.revision)
}
inline void VulnerabilityType_Version::set_revision(const char* value, size_t size) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.revision)
}
inline ::std::string* VulnerabilityType_Version::mutable_revision() {
  
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.revision)
  return revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VulnerabilityType_Version::release_revision() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.revision)
  
  return revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VulnerabilityType_Version::set_allocated_revision(::std::string* revision) {
  if (revision != NULL) {
    
  } else {
    
  }
  revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), revision);
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.revision)
}

// .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.VersionKind kind = 5;
inline void VulnerabilityType_Version::clear_kind() {
  kind_ = 0;
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version_VersionKind VulnerabilityType_Version::kind() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.kind)
  return static_cast< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version_VersionKind >(kind_);
}
inline void VulnerabilityType_Version::set_kind(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version_VersionKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version.kind)
}

// -------------------------------------------------------------------

// VulnerabilityType_Detail

// string cpe_uri = 1;
inline void VulnerabilityType_Detail::clear_cpe_uri() {
  cpe_uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VulnerabilityType_Detail::cpe_uri() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.cpe_uri)
  return cpe_uri_.GetNoArena();
}
inline void VulnerabilityType_Detail::set_cpe_uri(const ::std::string& value) {
  
  cpe_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.cpe_uri)
}
#if LANG_CXX11
inline void VulnerabilityType_Detail::set_cpe_uri(::std::string&& value) {
  
  cpe_uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.cpe_uri)
}
#endif
inline void VulnerabilityType_Detail::set_cpe_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cpe_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.cpe_uri)
}
inline void VulnerabilityType_Detail::set_cpe_uri(const char* value, size_t size) {
  
  cpe_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.cpe_uri)
}
inline ::std::string* VulnerabilityType_Detail::mutable_cpe_uri() {
  
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.cpe_uri)
  return cpe_uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VulnerabilityType_Detail::release_cpe_uri() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.cpe_uri)
  
  return cpe_uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VulnerabilityType_Detail::set_allocated_cpe_uri(::std::string* cpe_uri) {
  if (cpe_uri != NULL) {
    
  } else {
    
  }
  cpe_uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cpe_uri);
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.cpe_uri)
}

// string package = 8;
inline void VulnerabilityType_Detail::clear_package() {
  package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VulnerabilityType_Detail::package() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package)
  return package_.GetNoArena();
}
inline void VulnerabilityType_Detail::set_package(const ::std::string& value) {
  
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package)
}
#if LANG_CXX11
inline void VulnerabilityType_Detail::set_package(::std::string&& value) {
  
  package_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package)
}
#endif
inline void VulnerabilityType_Detail::set_package(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package)
}
inline void VulnerabilityType_Detail::set_package(const char* value, size_t size) {
  
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package)
}
inline ::std::string* VulnerabilityType_Detail::mutable_package() {
  
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package)
  return package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VulnerabilityType_Detail::release_package() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package)
  
  return package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VulnerabilityType_Detail::set_allocated_package(::std::string* package) {
  if (package != NULL) {
    
  } else {
    
  }
  package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package);
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package)
}

// .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version min_affected_version = 6;
inline bool VulnerabilityType_Detail::has_min_affected_version() const {
  return this != internal_default_instance() && min_affected_version_ != NULL;
}
inline void VulnerabilityType_Detail::clear_min_affected_version() {
  if (GetArenaNoVirtual() == NULL && min_affected_version_ != NULL) {
    delete min_affected_version_;
  }
  min_affected_version_ = NULL;
}
inline const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version& VulnerabilityType_Detail::_internal_min_affected_version() const {
  return *min_affected_version_;
}
inline const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version& VulnerabilityType_Detail::min_affected_version() const {
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* p = min_affected_version_;
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.min_affected_version)
  return p != NULL ? *p : *reinterpret_cast<const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version*>(
      &::google::devtools::containeranalysis::v1alpha1::_VulnerabilityType_Version_default_instance_);
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* VulnerabilityType_Detail::release_min_affected_version() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.min_affected_version)
  
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* temp = min_affected_version_;
  min_affected_version_ = NULL;
  return temp;
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* VulnerabilityType_Detail::mutable_min_affected_version() {
  
  if (min_affected_version_ == NULL) {
    auto* p = CreateMaybeMessage<::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version>(GetArenaNoVirtual());
    min_affected_version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.min_affected_version)
  return min_affected_version_;
}
inline void VulnerabilityType_Detail::set_allocated_min_affected_version(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* min_affected_version) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete min_affected_version_;
  }
  if (min_affected_version) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      min_affected_version = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, min_affected_version, submessage_arena);
    }
    
  } else {
    
  }
  min_affected_version_ = min_affected_version;
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.min_affected_version)
}

// .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version max_affected_version = 7;
inline bool VulnerabilityType_Detail::has_max_affected_version() const {
  return this != internal_default_instance() && max_affected_version_ != NULL;
}
inline void VulnerabilityType_Detail::clear_max_affected_version() {
  if (GetArenaNoVirtual() == NULL && max_affected_version_ != NULL) {
    delete max_affected_version_;
  }
  max_affected_version_ = NULL;
}
inline const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version& VulnerabilityType_Detail::_internal_max_affected_version() const {
  return *max_affected_version_;
}
inline const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version& VulnerabilityType_Detail::max_affected_version() const {
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* p = max_affected_version_;
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.max_affected_version)
  return p != NULL ? *p : *reinterpret_cast<const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version*>(
      &::google::devtools::containeranalysis::v1alpha1::_VulnerabilityType_Version_default_instance_);
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* VulnerabilityType_Detail::release_max_affected_version() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.max_affected_version)
  
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* temp = max_affected_version_;
  max_affected_version_ = NULL;
  return temp;
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* VulnerabilityType_Detail::mutable_max_affected_version() {
  
  if (max_affected_version_ == NULL) {
    auto* p = CreateMaybeMessage<::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version>(GetArenaNoVirtual());
    max_affected_version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.max_affected_version)
  return max_affected_version_;
}
inline void VulnerabilityType_Detail::set_allocated_max_affected_version(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* max_affected_version) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete max_affected_version_;
  }
  if (max_affected_version) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      max_affected_version = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, max_affected_version, submessage_arena);
    }
    
  } else {
    
  }
  max_affected_version_ = max_affected_version;
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.max_affected_version)
}

// string severity_name = 4;
inline void VulnerabilityType_Detail::clear_severity_name() {
  severity_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VulnerabilityType_Detail::severity_name() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.severity_name)
  return severity_name_.GetNoArena();
}
inline void VulnerabilityType_Detail::set_severity_name(const ::std::string& value) {
  
  severity_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.severity_name)
}
#if LANG_CXX11
inline void VulnerabilityType_Detail::set_severity_name(::std::string&& value) {
  
  severity_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.severity_name)
}
#endif
inline void VulnerabilityType_Detail::set_severity_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  severity_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.severity_name)
}
inline void VulnerabilityType_Detail::set_severity_name(const char* value, size_t size) {
  
  severity_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.severity_name)
}
inline ::std::string* VulnerabilityType_Detail::mutable_severity_name() {
  
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.severity_name)
  return severity_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VulnerabilityType_Detail::release_severity_name() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.severity_name)
  
  return severity_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VulnerabilityType_Detail::set_allocated_severity_name(::std::string* severity_name) {
  if (severity_name != NULL) {
    
  } else {
    
  }
  severity_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), severity_name);
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.severity_name)
}

// string description = 9;
inline void VulnerabilityType_Detail::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VulnerabilityType_Detail::description() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.description)
  return description_.GetNoArena();
}
inline void VulnerabilityType_Detail::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.description)
}
#if LANG_CXX11
inline void VulnerabilityType_Detail::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.description)
}
#endif
inline void VulnerabilityType_Detail::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.description)
}
inline void VulnerabilityType_Detail::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.description)
}
inline ::std::string* VulnerabilityType_Detail::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VulnerabilityType_Detail::release_description() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VulnerabilityType_Detail::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.description)
}

// .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation fixed_location = 5;
inline bool VulnerabilityType_Detail::has_fixed_location() const {
  return this != internal_default_instance() && fixed_location_ != NULL;
}
inline void VulnerabilityType_Detail::clear_fixed_location() {
  if (GetArenaNoVirtual() == NULL && fixed_location_ != NULL) {
    delete fixed_location_;
  }
  fixed_location_ = NULL;
}
inline const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation& VulnerabilityType_Detail::_internal_fixed_location() const {
  return *fixed_location_;
}
inline const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation& VulnerabilityType_Detail::fixed_location() const {
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* p = fixed_location_;
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.fixed_location)
  return p != NULL ? *p : *reinterpret_cast<const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation*>(
      &::google::devtools::containeranalysis::v1alpha1::_VulnerabilityType_VulnerabilityLocation_default_instance_);
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* VulnerabilityType_Detail::release_fixed_location() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.fixed_location)
  
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* temp = fixed_location_;
  fixed_location_ = NULL;
  return temp;
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* VulnerabilityType_Detail::mutable_fixed_location() {
  
  if (fixed_location_ == NULL) {
    auto* p = CreateMaybeMessage<::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation>(GetArenaNoVirtual());
    fixed_location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.fixed_location)
  return fixed_location_;
}
inline void VulnerabilityType_Detail::set_allocated_fixed_location(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* fixed_location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fixed_location_;
  }
  if (fixed_location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fixed_location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fixed_location, submessage_arena);
    }
    
  } else {
    
  }
  fixed_location_ = fixed_location;
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.fixed_location)
}

// string package_type = 10;
inline void VulnerabilityType_Detail::clear_package_type() {
  package_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VulnerabilityType_Detail::package_type() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package_type)
  return package_type_.GetNoArena();
}
inline void VulnerabilityType_Detail::set_package_type(const ::std::string& value) {
  
  package_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package_type)
}
#if LANG_CXX11
inline void VulnerabilityType_Detail::set_package_type(::std::string&& value) {
  
  package_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package_type)
}
#endif
inline void VulnerabilityType_Detail::set_package_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  package_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package_type)
}
inline void VulnerabilityType_Detail::set_package_type(const char* value, size_t size) {
  
  package_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package_type)
}
inline ::std::string* VulnerabilityType_Detail::mutable_package_type() {
  
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package_type)
  return package_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VulnerabilityType_Detail::release_package_type() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package_type)
  
  return package_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VulnerabilityType_Detail::set_allocated_package_type(::std::string* package_type) {
  if (package_type != NULL) {
    
  } else {
    
  }
  package_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package_type);
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.package_type)
}

// bool is_obsolete = 11;
inline void VulnerabilityType_Detail::clear_is_obsolete() {
  is_obsolete_ = false;
}
inline bool VulnerabilityType_Detail::is_obsolete() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.is_obsolete)
  return is_obsolete_;
}
inline void VulnerabilityType_Detail::set_is_obsolete(bool value) {
  
  is_obsolete_ = value;
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail.is_obsolete)
}

// -------------------------------------------------------------------

// VulnerabilityType_VulnerabilityDetails

// string type = 3;
inline void VulnerabilityType_VulnerabilityDetails::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VulnerabilityType_VulnerabilityDetails::type() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.type)
  return type_.GetNoArena();
}
inline void VulnerabilityType_VulnerabilityDetails::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.type)
}
#if LANG_CXX11
inline void VulnerabilityType_VulnerabilityDetails::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.type)
}
#endif
inline void VulnerabilityType_VulnerabilityDetails::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.type)
}
inline void VulnerabilityType_VulnerabilityDetails::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.type)
}
inline ::std::string* VulnerabilityType_VulnerabilityDetails::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VulnerabilityType_VulnerabilityDetails::release_type() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VulnerabilityType_VulnerabilityDetails::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.type)
}

// .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Severity severity = 4;
inline void VulnerabilityType_VulnerabilityDetails::clear_severity() {
  severity_ = 0;
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Severity VulnerabilityType_VulnerabilityDetails::severity() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.severity)
  return static_cast< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Severity >(severity_);
}
inline void VulnerabilityType_VulnerabilityDetails::set_severity(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Severity value) {
  
  severity_ = value;
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.severity)
}

// float cvss_score = 5;
inline void VulnerabilityType_VulnerabilityDetails::clear_cvss_score() {
  cvss_score_ = 0;
}
inline float VulnerabilityType_VulnerabilityDetails::cvss_score() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.cvss_score)
  return cvss_score_;
}
inline void VulnerabilityType_VulnerabilityDetails::set_cvss_score(float value) {
  
  cvss_score_ = value;
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.cvss_score)
}

// repeated .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue package_issue = 6;
inline int VulnerabilityType_VulnerabilityDetails::package_issue_size() const {
  return package_issue_.size();
}
inline void VulnerabilityType_VulnerabilityDetails::clear_package_issue() {
  package_issue_.Clear();
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_PackageIssue* VulnerabilityType_VulnerabilityDetails::mutable_package_issue(int index) {
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.package_issue)
  return package_issue_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_PackageIssue >*
VulnerabilityType_VulnerabilityDetails::mutable_package_issue() {
  // @@protoc_insertion_point(field_mutable_list:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.package_issue)
  return &package_issue_;
}
inline const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_PackageIssue& VulnerabilityType_VulnerabilityDetails::package_issue(int index) const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.package_issue)
  return package_issue_.Get(index);
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_PackageIssue* VulnerabilityType_VulnerabilityDetails::add_package_issue() {
  // @@protoc_insertion_point(field_add:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.package_issue)
  return package_issue_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_PackageIssue >&
VulnerabilityType_VulnerabilityDetails::package_issue() const {
  // @@protoc_insertion_point(field_list:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityDetails.package_issue)
  return package_issue_;
}

// -------------------------------------------------------------------

// VulnerabilityType_PackageIssue

// .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation affected_location = 1;
inline bool VulnerabilityType_PackageIssue::has_affected_location() const {
  return this != internal_default_instance() && affected_location_ != NULL;
}
inline void VulnerabilityType_PackageIssue::clear_affected_location() {
  if (GetArenaNoVirtual() == NULL && affected_location_ != NULL) {
    delete affected_location_;
  }
  affected_location_ = NULL;
}
inline const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation& VulnerabilityType_PackageIssue::_internal_affected_location() const {
  return *affected_location_;
}
inline const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation& VulnerabilityType_PackageIssue::affected_location() const {
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* p = affected_location_;
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.affected_location)
  return p != NULL ? *p : *reinterpret_cast<const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation*>(
      &::google::devtools::containeranalysis::v1alpha1::_VulnerabilityType_VulnerabilityLocation_default_instance_);
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* VulnerabilityType_PackageIssue::release_affected_location() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.affected_location)
  
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* temp = affected_location_;
  affected_location_ = NULL;
  return temp;
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* VulnerabilityType_PackageIssue::mutable_affected_location() {
  
  if (affected_location_ == NULL) {
    auto* p = CreateMaybeMessage<::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation>(GetArenaNoVirtual());
    affected_location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.affected_location)
  return affected_location_;
}
inline void VulnerabilityType_PackageIssue::set_allocated_affected_location(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* affected_location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete affected_location_;
  }
  if (affected_location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      affected_location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, affected_location, submessage_arena);
    }
    
  } else {
    
  }
  affected_location_ = affected_location;
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.affected_location)
}

// .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation fixed_location = 2;
inline bool VulnerabilityType_PackageIssue::has_fixed_location() const {
  return this != internal_default_instance() && fixed_location_ != NULL;
}
inline void VulnerabilityType_PackageIssue::clear_fixed_location() {
  if (GetArenaNoVirtual() == NULL && fixed_location_ != NULL) {
    delete fixed_location_;
  }
  fixed_location_ = NULL;
}
inline const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation& VulnerabilityType_PackageIssue::_internal_fixed_location() const {
  return *fixed_location_;
}
inline const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation& VulnerabilityType_PackageIssue::fixed_location() const {
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* p = fixed_location_;
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.fixed_location)
  return p != NULL ? *p : *reinterpret_cast<const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation*>(
      &::google::devtools::containeranalysis::v1alpha1::_VulnerabilityType_VulnerabilityLocation_default_instance_);
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* VulnerabilityType_PackageIssue::release_fixed_location() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.fixed_location)
  
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* temp = fixed_location_;
  fixed_location_ = NULL;
  return temp;
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* VulnerabilityType_PackageIssue::mutable_fixed_location() {
  
  if (fixed_location_ == NULL) {
    auto* p = CreateMaybeMessage<::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation>(GetArenaNoVirtual());
    fixed_location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.fixed_location)
  return fixed_location_;
}
inline void VulnerabilityType_PackageIssue::set_allocated_fixed_location(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_VulnerabilityLocation* fixed_location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fixed_location_;
  }
  if (fixed_location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fixed_location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fixed_location, submessage_arena);
    }
    
  } else {
    
  }
  fixed_location_ = fixed_location;
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.fixed_location)
}

// string severity_name = 3;
inline void VulnerabilityType_PackageIssue::clear_severity_name() {
  severity_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VulnerabilityType_PackageIssue::severity_name() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.severity_name)
  return severity_name_.GetNoArena();
}
inline void VulnerabilityType_PackageIssue::set_severity_name(const ::std::string& value) {
  
  severity_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.severity_name)
}
#if LANG_CXX11
inline void VulnerabilityType_PackageIssue::set_severity_name(::std::string&& value) {
  
  severity_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.severity_name)
}
#endif
inline void VulnerabilityType_PackageIssue::set_severity_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  severity_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.severity_name)
}
inline void VulnerabilityType_PackageIssue::set_severity_name(const char* value, size_t size) {
  
  severity_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.severity_name)
}
inline ::std::string* VulnerabilityType_PackageIssue::mutable_severity_name() {
  
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.severity_name)
  return severity_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VulnerabilityType_PackageIssue::release_severity_name() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.severity_name)
  
  return severity_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VulnerabilityType_PackageIssue::set_allocated_severity_name(::std::string* severity_name) {
  if (severity_name != NULL) {
    
  } else {
    
  }
  severity_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), severity_name);
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.PackageIssue.severity_name)
}

// -------------------------------------------------------------------

// VulnerabilityType_VulnerabilityLocation

// string cpe_uri = 1;
inline void VulnerabilityType_VulnerabilityLocation::clear_cpe_uri() {
  cpe_uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VulnerabilityType_VulnerabilityLocation::cpe_uri() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.cpe_uri)
  return cpe_uri_.GetNoArena();
}
inline void VulnerabilityType_VulnerabilityLocation::set_cpe_uri(const ::std::string& value) {
  
  cpe_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.cpe_uri)
}
#if LANG_CXX11
inline void VulnerabilityType_VulnerabilityLocation::set_cpe_uri(::std::string&& value) {
  
  cpe_uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.cpe_uri)
}
#endif
inline void VulnerabilityType_VulnerabilityLocation::set_cpe_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cpe_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.cpe_uri)
}
inline void VulnerabilityType_VulnerabilityLocation::set_cpe_uri(const char* value, size_t size) {
  
  cpe_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.cpe_uri)
}
inline ::std::string* VulnerabilityType_VulnerabilityLocation::mutable_cpe_uri() {
  
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.cpe_uri)
  return cpe_uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VulnerabilityType_VulnerabilityLocation::release_cpe_uri() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.cpe_uri)
  
  return cpe_uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VulnerabilityType_VulnerabilityLocation::set_allocated_cpe_uri(::std::string* cpe_uri) {
  if (cpe_uri != NULL) {
    
  } else {
    
  }
  cpe_uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cpe_uri);
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.cpe_uri)
}

// string package = 2;
inline void VulnerabilityType_VulnerabilityLocation::clear_package() {
  package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VulnerabilityType_VulnerabilityLocation::package() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.package)
  return package_.GetNoArena();
}
inline void VulnerabilityType_VulnerabilityLocation::set_package(const ::std::string& value) {
  
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.package)
}
#if LANG_CXX11
inline void VulnerabilityType_VulnerabilityLocation::set_package(::std::string&& value) {
  
  package_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.package)
}
#endif
inline void VulnerabilityType_VulnerabilityLocation::set_package(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.package)
}
inline void VulnerabilityType_VulnerabilityLocation::set_package(const char* value, size_t size) {
  
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.package)
}
inline ::std::string* VulnerabilityType_VulnerabilityLocation::mutable_package() {
  
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.package)
  return package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VulnerabilityType_VulnerabilityLocation::release_package() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.package)
  
  return package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VulnerabilityType_VulnerabilityLocation::set_allocated_package(::std::string* package) {
  if (package != NULL) {
    
  } else {
    
  }
  package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package);
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.package)
}

// .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Version version = 4;
inline bool VulnerabilityType_VulnerabilityLocation::has_version() const {
  return this != internal_default_instance() && version_ != NULL;
}
inline void VulnerabilityType_VulnerabilityLocation::clear_version() {
  if (GetArenaNoVirtual() == NULL && version_ != NULL) {
    delete version_;
  }
  version_ = NULL;
}
inline const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version& VulnerabilityType_VulnerabilityLocation::_internal_version() const {
  return *version_;
}
inline const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version& VulnerabilityType_VulnerabilityLocation::version() const {
  const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* p = version_;
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.version)
  return p != NULL ? *p : *reinterpret_cast<const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version*>(
      &::google::devtools::containeranalysis::v1alpha1::_VulnerabilityType_Version_default_instance_);
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* VulnerabilityType_VulnerabilityLocation::release_version() {
  // @@protoc_insertion_point(field_release:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.version)
  
  ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* temp = version_;
  version_ = NULL;
  return temp;
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* VulnerabilityType_VulnerabilityLocation::mutable_version() {
  
  if (version_ == NULL) {
    auto* p = CreateMaybeMessage<::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version>(GetArenaNoVirtual());
    version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.version)
  return version_;
}
inline void VulnerabilityType_VulnerabilityLocation::set_allocated_version(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version* version) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete version_;
  }
  if (version) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      version = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.VulnerabilityLocation.version)
}

// -------------------------------------------------------------------

// VulnerabilityType

// float cvss_score = 2;
inline void VulnerabilityType::clear_cvss_score() {
  cvss_score_ = 0;
}
inline float VulnerabilityType::cvss_score() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.cvss_score)
  return cvss_score_;
}
inline void VulnerabilityType::set_cvss_score(float value) {
  
  cvss_score_ = value;
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.cvss_score)
}

// .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Severity severity = 3;
inline void VulnerabilityType::clear_severity() {
  severity_ = 0;
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Severity VulnerabilityType::severity() const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.severity)
  return static_cast< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Severity >(severity_);
}
inline void VulnerabilityType::set_severity(::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Severity value) {
  
  severity_ = value;
  // @@protoc_insertion_point(field_set:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.severity)
}

// repeated .google.devtools.containeranalysis.v1alpha1.VulnerabilityType.Detail details = 4;
inline int VulnerabilityType::details_size() const {
  return details_.size();
}
inline void VulnerabilityType::clear_details() {
  details_.Clear();
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Detail* VulnerabilityType::mutable_details(int index) {
  // @@protoc_insertion_point(field_mutable:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.details)
  return details_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Detail >*
VulnerabilityType::mutable_details() {
  // @@protoc_insertion_point(field_mutable_list:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.details)
  return &details_;
}
inline const ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Detail& VulnerabilityType::details(int index) const {
  // @@protoc_insertion_point(field_get:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.details)
  return details_.Get(index);
}
inline ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Detail* VulnerabilityType::add_details() {
  // @@protoc_insertion_point(field_add:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.details)
  return details_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Detail >&
VulnerabilityType::details() const {
  // @@protoc_insertion_point(field_list:google.devtools.containeranalysis.v1alpha1.VulnerabilityType.details)
  return details_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace containeranalysis
}  // namespace devtools
}  // namespace google

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version_VersionKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version_VersionKind>() {
  return ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Version_VersionKind_descriptor();
}
template <> struct is_proto_enum< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Severity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Severity>() {
  return ::google::devtools::containeranalysis::v1alpha1::VulnerabilityType_Severity_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_google_2fdevtools_2fcontaineranalysis_2fv1alpha1_2fpackage_5fvulnerability_2eproto
